; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optsize -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\assemble.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME2"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME2",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",16
.DEFINE "reg"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "reg_index"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "indirect"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "cc"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "cc_index"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "displacement"
.VALUE 7
.CLASS 8
.TYPE 3
.ENDEF
.DEFINE "displacement_provided"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "immediate_provided"
.VALUE 10
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "immediate"
.VALUE 11
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "wasLabel"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",4
.DEFINE "suffix"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "prefix1"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "prefix2"
.VALUE 2
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "opcode"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",16
.DEFINE "operandA"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "operandB"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "ddfdpermitted"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "transformA"
.VALUE 7
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "transformB"
.VALUE 10
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "prefix"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "opcode"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "adl"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",17
.DEFINE "name"
.VALUE 0
.CLASS 8
.DIM 8
.TYPE 98
.ENDEF
.DEFINE "type"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "asmtype"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "listnumber"
.VALUE 10
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "list"
.VALUE 11
.CLASS 8
.TAG "NONAME5"
.TYPE 40
.ENDEF
.DEFINE "asmargument"
.VALUE 14
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME6"
.BEGREC "NONAME7",6
.DEFINE "type"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "match"
.VALUE 3
.CLASS 8
.TYPE 556
.ENDEF
.ENDREC "NONAME7"
.BEGREC "NONAME8",7
.DEFINE "name"
.VALUE 0
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "address"
.VALUE 3
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME8"
.BEGREC "NONAME9",5
.DEFINE "defined"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "address"
.VALUE 1
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME9"
.BEGREC "NONAME10",264
.DEFINE "current_instruction"
.VALUE 0
.CLASS 8
.TAG "NONAME6"
.TYPE 40
.ENDEF
.DEFINE "next"
.VALUE 3
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "label"
.VALUE 6
.CLASS 8
.DIM 32
.TYPE 98
.ENDEF
.DEFINE "mnemonic"
.VALUE 38
.CLASS 8
.DIM 16
.TYPE 98
.ENDEF
.DEFINE "suffix"
.VALUE 54
.CLASS 8
.DIM 16
.TYPE 98
.ENDEF
.DEFINE "operand1"
.VALUE 70
.CLASS 8
.DIM 32
.TYPE 98
.ENDEF
.DEFINE "operand2"
.VALUE 102
.CLASS 8
.DIM 32
.TYPE 98
.ENDEF
.DEFINE "comment"
.VALUE 134
.CLASS 8
.DIM 128
.TYPE 98
.ENDEF
.DEFINE "size"
.VALUE 262
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "NONAME10"
.BEGREC "NONAME11",261
.DEFINE "start"
.VALUE 0
.CLASS 8
.DIM 256
.TYPE 98
.ENDEF
.DEFINE "length"
.VALUE 256
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "next"
.VALUE 257
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "terminator"
.VALUE 260
.CLASS 8
.TYPE 2
.ENDEF
.ENDREC "NONAME11"
.BEGREC "NONAME12",131
.DEFINE "linenumber"
.VALUE 0
.CLASS 8
.TYPE 13
.ENDEF
.DEFINE "fp"
.VALUE 2
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "filename"
.VALUE 3
.CLASS 8
.DIM 128
.TYPE 98
.ENDEF
.ENDREC "NONAME12"
;    1	#include <stdio.h>
;    2	#include <string.h>
;    3	#include <stdlib.h>
;    4	#include <ctype.h>
;    5	#include <stdint.h>
;    6	#include <stdarg.h>
;    7	#include "assemble.h"
;    8	#include "globals.h"
;    9	#include "utils.h"
;   10	#include "label.h"
;   11	#include "str2num.h"
;   12	#include "listing.h"
;   13	#include "filestack.h"
;   14	#include "stdint.h"
;   15	#include "mos-interface.h"
;   16	
;   17	void empty_operand(operand *op) {
_empty_operand:
.DEFINE "_empty_operand"

.VALUE _empty_operand

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "empty_operand",17,"_empty_operand"

.LINE 17

.DEFINE "op"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   18	    op->reg = R_NONE;
.LINE 18

	LD	BC,0
	LD	IY,(IX+%6)
	LD	(IY+%0),BC
;   19	    op->reg_index = 0;
.LINE 19

	LD	(IY+%3),%0
;   20	    op->cc = false;
.LINE 20

	LD	(IY+%5),%0
;   21	    op->cc_index = 0;
.LINE 21

	LD	(IY+%6),%0
;   22	    op->displacement = 0;
.LINE 22

	LD	(IY+%7),%0
	LD	(IY+%8),%0
;   23	    op->displacement_provided = false;
.LINE 23

	LD	(IY+%9),%0
;   24	    op->immediate = 0;
.LINE 24

	LD	(IY+%B),BC
	LD	(IY+%E),%0
;   25	    op->immediate_provided = false;
.LINE 25

	LD	(IY+%A),%0
;   26	    op->wasLabel = false;
.LINE 26

	LD	(IY+%F),%0
;   27	}
.LINE 27

	LD	SP,IX
	POP	IX
	RET	


;**************************** _empty_operand ***************************
;Name                         Addr/Register   Size   Type
;op                                    IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "empty_operand",27,"_empty_operand"
;   28	
;   29	void advanceLocalLabel(void) {
_advanceLocalLabel:
.DEFINE "_advanceLocalLabel"

.VALUE _advanceLocalLabel

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "advanceLocalLabel",29,"_advanceLocalLabel"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   30	    if(currentline.label[0] == '@') {
.LINE 30

	LD	A,(_currentline+6)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,64
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_3
;   31	        if(currentline.label[1] == '@') {
.LINE 31

	LD	HL,_currentline+6
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,64
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_3
;   32	            readAnonymousLabel();
.LINE 32

	CALL	_readAnonymousLabel
;   33	        }
;   34	    }
;   35	}
L_3:
.LINE 35

	LD	SP,IX
	POP	IX
	RET	


;**************************** _advanceLocalLabel ***************************
;Name                         Addr/Register   Size   Type
;_readAnonymousLabel                 IMPORT  -----   function
;_currentline                        IMPORT    264   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "advanceLocalLabel",35,"_advanceLocalLabel"
;   36	
;   37	// Get the ascii value from a single 'x' token.
;   38	uint8_t getAsciiValue(char *string) {
_getAsciiValue:
.DEFINE "_getAsciiValue"

.VALUE _getAsciiValue

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "getAsciiValue",38,"_getAsciiValue"

.LINE 38

.DEFINE "string"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "len"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;   39	    uint8_t len = strlen(string);
.LINE 39

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+%FFFFFFFF),L
;   40	
;   41	    if((len == 3) || (len == 4)) {
.LINE 41

	LD	A,(IX+%FFFFFFFF)
	CP	A,%3
	JR	Z,L_19
	LD	A,(IX+%FFFFFFFF)
	CP	A,%4
	JR	NZ,L_20
L_19:
;   42	        if(*string == '\'') {
.LINE 42

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,39
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_20
;   43	            if((len == 4) && (string[3] == '\'') && (string[1] == '\\')) {
.LINE 43

	LD	A,(IX+%FFFFFFFF)
	CP	A,%4
	JR	NZ,L_17
	LD	IY,(IX+%6)
	LEA	HL,IY+%3
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,39
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_17
	LD	HL,(IX+%6)
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,92
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_17
;   44	                switch(string[2]) {
.LINE 44

	LD	IY,(IX+%6)
	LEA	HL,IY+%2
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	CALL	__case8D
	JP	(HL)
L__10:
	DW	7
	DB	34
	DW24	L_12	

	DB	39
	DW24	L_13	

	DB	92
	DW24	L_11	

	DB	98
	DW24	L_10	

	DB	110
	DW24	L_7	

	DB	114
	DW24	L_8	

	DB	116
	DW24	L_9	

	DW24	L_17	

;   45	                    case 'n': return '\n';
L_7:
.LINE 45

	LD	A,%A
	JR	L_21
;   46	                    case 'r': return '\r';
L_8:
.LINE 46

	LD	A,%D
	JR	L_21
;   47	                    case 't': return '\t';
L_9:
.LINE 47

	LD	A,%9
	JR	L_21
;   48	                    case 'b': return '\b';
L_10:
.LINE 48

	LD	A,%8
	JR	L_21
;   49	                    case '\\': return '\\';
L_11:
.LINE 49

	LD	A,%5C
	JR	L_21
;   50	                    case '\"': return '\"';
L_12:
.LINE 50

	LD	A,%22
	JR	L_21
;   51	                    case '\'': return '\'';
L_13:
.LINE 51

	LD	A,%27
	JR	L_21
;   52	                }
;   53	            }
L_17:
.LINE 53

;   54	            if((len == 3) && (string[2] == '\'')) {
.LINE 54

	LD	A,(IX+%FFFFFFFF)
	CP	A,%3
	JR	NZ,L_20
	LD	IY,(IX+%6)
	LEA	HL,IY+%2
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,39
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_20
;   55	                return string[1];
.LINE 55

	LD	HL,(IX+%6)
	INC	HL
	LD	A,(HL)
	JR	L_21
;   56	            }
;   57	        }
;   58	    }
L_20:
.LINE 58

;   59	    error(message[ERROR_ASCIIFORMAT]);
.LINE 59

	LD	HL,_message+108
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;   60	    return 0;
.LINE 60

	XOR	A,A
;   61	}
L_21:
.LINE 61

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getAsciiValue ***************************
;Name                         Addr/Register   Size   Type
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;len                                   IX-1      1   variable
;string                                IX+6      3   parameter


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getAsciiValue",61,"_getAsciiValue"
;   62	
;   63	// Get the value from a sequence of 0-n labels and values, separated by +/- operators
;   64	// Examples:
;   65	// labela+5
;   66	// labelb-1
;   67	// labela+labelb+offset1-1
;   68	// The string should not contain any spaces, needs to be a single token
;   69	int32_t getLabelValue(char *string) {
_getLabelValue:
.DEFINE "_getLabelValue"

.VALUE _getLabelValue

.CLASS 2

.TYPE 69

.ENDEF

.BEGFUNC "getLabelValue",69,"_getLabelValue"

.LINE 69

.DEFINE "string"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "operator"

.CLASS 65

.VALUE -1

.TYPE 2

.ENDEF

.DEFINE "total"

.CLASS 65

.VALUE -5

.TYPE 5

.ENDEF

.DEFINE "tmp"

.CLASS 65

.VALUE -9

.TYPE 5

.ENDEF

.DEFINE "ptr"

.CLASS 65

.VALUE -12

.TYPE 34

.ENDEF

.DEFINE "lbl"

.CLASS 65

.VALUE -18

.TAG "NONAME8"

.TYPE 40

.ENDEF

.DEFINE "token"

.CLASS 65

.VALUE -279

.TAG "NONAME11"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-279
	ADD	HL,SP
	LD	SP,HL
;   70	    int32_t total, tmp;
;   71	    char operator, *ptr;
;   72	    label *lbl;
;   73	    tokentype token;
;   74	
;   75	    ptr = string;
.LINE 75

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFF4),BC
;   76	    total = 0;
.LINE 76

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFFB),BC
	LD	(IX+%FFFFFFFE),A
;   77	    operator = '+'; // previous operand in case of single value/label
.LINE 77

	LD	(IX+%FFFFFFFF),%2B
;   78	    while(ptr) {
.LINE 78

	JR	L_42
L_43:
;   79	        tmp = 0;
.LINE 79

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFF7),BC
	LD	(IX+%FFFFFFFA),A
;   80	        getOperatorToken(&token, ptr);
.LINE 80

	LD	BC,(IX+%FFFFFFF4)
	PUSH	BC
	LD	HL,IX
	LD	BC,-279
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getOperatorToken
	POP	BC
	POP	BC
;   81	        if(notEmpty(token.start)) {
.LINE 81

	LD	HL,IX
	LD	BC,-279
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_notEmpty
	POP	BC
	OR	A,A
	JR	Z,L_30
;   82	            lbl = findLabel(token.start);
.LINE 82

	LD	HL,IX
	LD	BC,-279
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_findLabel
	POP	BC
	LD	(IX+%FFFFFFEE),HL
;   83	            if(lbl) tmp = lbl->address;
.LINE 83

	CALL	__icmpzero
	JR	Z,L_27
	LD	IY,(IX+%FFFFFFEE)
	LD	BC,(IY+%3)
	LD	A,(IY+%6)
	LD	(IX+%FFFFFFF7),BC
	LD	(IX+%FFFFFFFA),A
;   84	            else {
.LINE 84

	JR	L_30
L_27:
;   85	                if(token.start[0] == '\'') tmp = getAsciiValue(token.start);
.LINE 85

	LD	HL,IX
	LD	BC,-279
	ADD	HL,BC
	LD	(IX+%FFFFFFF1),HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,39
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_25
	LD	BC,(IX+%FFFFFFF1)
	PUSH	BC
	CALL	_getAsciiValue
	POP	BC
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFF7),HL
	LD	(IX+%FFFFFFFA),H
;   86	                else {
.LINE 86

	JR	L_30
L_25:
;   87	                    tmp = str2num(token.start, false);
.LINE 87

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF1)
	PUSH	BC
	CALL	_str2num
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF7),HL
	LD	(IX+%FFFFFFFA),E
;   88	                    if(err_str2num && (pass == 2)) error(message[ERROR_INVALIDLABEL]);
.LINE 88

	LD	A,(_err_str2num)
	OR	A,A
	JR	Z,L_30
	LD	BC,2
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_30
	LD	HL,_message+12
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;   89	                }
;   90	            }
;   91	        }
L_30:
.LINE 91

;   92	        if(operator == '!') error(message[ERROR_OPERATOR]);
.LINE 92

	LD	A,(IX+%FFFFFFFF)
	CP	A,%21
	JR	NZ,L_32
	LD	HL,_message+114
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_32:
;   93	        if(operator == '+') total += tmp;
.LINE 93

	LD	A,(IX+%FFFFFFFF)
	CP	A,%2B
	JR	NZ,L_34
	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,(IX+%FFFFFFF7)
	LD	A,(IX+%FFFFFFFA)
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
L_34:
;   94	        if(operator == '-') total -= tmp;
.LINE 94

	LD	A,(IX+%FFFFFFFF)
	CP	A,%2D
	JR	NZ,L_36
	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,(IX+%FFFFFFF7)
	LD	A,(IX+%FFFFFFFA)
	CALL	__lsub
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
L_36:
;   95	        if(operator == '<') total = total << tmp;
.LINE 95

	LD	A,(IX+%FFFFFFFF)
	CP	A,%3C
	JR	NZ,L_38
	LD	HL,(IX+%FFFFFFF7)
	LD	BC,(IX+%FFFFFFFB)
	LD	A,(IX+%FFFFFFFE)
	CALL	__lshl
	LD	(IX+%FFFFFFFB),BC
	LD	(IX+%FFFFFFFE),A
L_38:
;   96	        if(operator == '>') total = total >> tmp;
.LINE 96

	LD	A,(IX+%FFFFFFFF)
	CP	A,%3E
	JR	NZ,L_39
	LD	HL,(IX+%FFFFFFF7)
	LD	BC,(IX+%FFFFFFFB)
	LD	A,(IX+%FFFFFFFE)
	CALL	__lshrs
	LD	(IX+%FFFFFFFB),BC
	LD	(IX+%FFFFFFFE),A
L_39:
;   97	        operator = token.terminator;
.LINE 97

	LD	A,(IX+%FFFFFFED)
	LD	(IX+%FFFFFFFF),A
;   98	
;   99	        if(operator) ptr = token.next;
.LINE 99

	OR	A,A
	JR	Z,L_41
	LD	BC,(IX+%FFFFFFEA)
	LD	(IX+%FFFFFFF4),BC
;  100	        else ptr = NULL;
.LINE 100

	JR	L_42
L_41:
	LD	BC,0
	LD	(IX+%FFFFFFF4),BC
;  101	    }
L_42:
.LINE 101

	LD	HL,(IX+%FFFFFFF4)
	CALL	__icmpzero
	JR	NZ,L_43
;  102	    return total;
.LINE 102

	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
;  103	}
.LINE 103

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getLabelValue ***************************
;Name                         Addr/Register   Size   Type
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_pass                               IMPORT      3   variable
;_err_str2num                        IMPORT      1   variable
;_str2num                            IMPORT  -----   function
;_findLabel                          IMPORT  -----   function
;_notEmpty                           IMPORT  -----   function
;_getOperatorToken                   IMPORT  -----   function
;token                               IX-279    261   variable
;lbl                                  IX-18      3   variable
;G_1                                  IX-15      3   variable
;ptr                                  IX-12      3   variable
;tmp                                   IX-9      4   variable
;total                                 IX-5      4   variable
;operator                              IX-1      1   variable
;string                                IX+6      3   parameter


; Stack Frame Size: 288 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getLabelValue",103,"_getLabelValue"
;  104	
;  105	// parses the given string to the operand, or throws errors along the way
;  106	// will destruct parts of the original string during the process
;  107	void parse_operand(char *string, operand *operand) {
_parse_operand:
.DEFINE "_parse_operand"

.VALUE _parse_operand

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "parse_operand",107,"_parse_operand"

.LINE 107

.DEFINE "string"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "operand"

.CLASS 65

.VALUE 9

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "ptr"

.CLASS 65

.VALUE -3

.TYPE 34

.ENDEF

.DEFINE "len"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFCC
	LD	SP,HL
;  108	    char *ptr = string;
.LINE 108

	LD	BC,(IX+%6)
	LD	(IX+%FFFFFFFD),BC
;  109	    uint8_t len = strlen(string);
.LINE 109

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+%FFFFFFFC),L
;  110	
;  111	    // direct or indirect
;  112	    if(*ptr == '(') {
.LINE 112

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,40
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_51
;  113	        operand->indirect = true;
.LINE 113

	LD	IY,(IX+%9)
	LD	(IY+%4),%1
;  114	        // find closing bracket or error out
;  115	        if(string[len-1] == ')') string[len-1] = 0; // terminate on closing bracket
.LINE 115

	LD	A,(IX+%FFFFFFFC)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%6)
	ADD	HL,BC
	DEC	HL
	LD	(IX+%FFFFFFF9),HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,41
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_47
	LD	HL,(IX+%FFFFFFF9)
	LD	(HL),%0
;  116	        else error(message[ERROR_CLOSINGBRACKET]);
.LINE 116

	JR	L_48
L_47:
	LD	HL,_message+6
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_48:
;  117	        ptr = &string[1];
.LINE 117

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  118	    }
;  119	    else {
.LINE 119

	JR	L_171
L_51:
;  120	        operand->indirect = false;
.LINE 120

	LD	IY,(IX+%9)
	LD	(IY+%4),%0
;  121	        // should not find a closing bracket
;  122	        if(string[len-1] == ')') error(message[ERROR_OPENINGBRACKET]);
.LINE 122

	LD	A,(IX+%FFFFFFFC)
	UEXT	HL
	LD	L,A
	LD	BC,(IX+%6)
	ADD	HL,BC
	DEC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,41
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_171
	LD	HL,_message+3
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  123	    }
L_171:
.LINE 123

;  124	
;  125	    switch(tolower(*ptr++)) {
.LINE 125

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF6),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__30:
	DW	15
	DB	0
	DW24	L_176	

	DB	97
	DW24	L_54	

	DB	98
	DW24	L_67	

	DB	99
	DW24	L_75	

	DB	100
	DW24	L_80	

	DB	101
	DW24	L_90	

	DB	104
	DW24	L_95	

	DB	105
	DW24	L_103	

	DB	108
	DW24	L_136	

	DB	109
	DW24	L_141	

	DB	110
	DW24	L_147	

	DB	112
	DW24	L_153	

	DB	114
	DW24	L_160	

	DB	115
	DW24	L_163	

	DB	122
	DW24	L_167	

	DW24	L_176	

;  126	        case 0: // empty operand
;  127	            break;
;  128	        case 'a':
L_54:
.LINE 128

;  129	            switch(tolower(*ptr++)) {
.LINE 129

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF3),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFF3)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__31:
	DW	2
	DB	0
	DW24	L_56	

	DB	102
	DW24	L_57	

	DW24	L_176	

;  130	                case 0:
L_56:
.LINE 130

;  131	                    operand->reg = R_A;
.LINE 131

	LD	BC,1
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  132	                    operand->reg_index = R_INDEX_A;
.LINE 132

	LD	(IY+%3),%7
;  133	                    return;
.LINE 133

	JR	L_177
;  134	                case 'f':
L_57:
.LINE 134

;  135	                    switch(tolower(*ptr++)) {
.LINE 135

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFF0),BC
	LD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__32:
	DW	2
	DB	0
	DW24	L_59	

	DB	39
	DW24	L_60	

	DW24	L_176	

;  136	                        case 0:
L_59:
.LINE 136

;  137	                        case '\'':
L_60:
.LINE 137

;  138	                            operand->reg = R_AF;
.LINE 138

	LD	BC,12
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  139	                            operand->reg_index = R_INDEX_AF;
.LINE 139

	LD	(IY+%3),%3
;  140	                            if(operand->indirect) error(message[ERROR_INVALIDREGISTER]);
.LINE 140

	LD	A,(IY+%4)
	OR	A,A
	JR	Z,L_177
	LD	BC,(_message)
	PUSH	BC
	CALL	_error
	POP	BC
;  141	                            return;
.LINE 141

	JR	L_177
;  142	                        default:
;  143	                            break;
;  144	                    }
;  145	                    break;
;  146	                default:
;  147	                    break;
;  148	            }
;  149	            break;
;  150	        case 'b':
L_67:
.LINE 150

;  151	            switch(tolower(*ptr++)) {
.LINE 151

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFED),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFED)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__34:
	DW	2
	DB	0
	DW24	L_69	

	DB	99
	DW24	L_70	

	DW24	L_176	

;  152	                case 0:
L_69:
.LINE 152

;  153	                    operand->reg = R_B;
.LINE 153

	LD	BC,2
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  154	                    operand->reg_index = R_INDEX_B;
.LINE 154

	LD	(IY+%3),%0
;  155	                    return;
.LINE 155

	JR	L_177
;  156	                case 'c':
L_70:
.LINE 156

;  157	                    if(tolower(*ptr == 0)) {
.LINE 157

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L__36
	LD	A,%1
	JR	L__37
L__36:
	XOR	A,A
L__37:
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_tolower
	POP	BC
	CALL	__icmpzero
	JR	Z,L_176
;  158	                        operand->reg = R_BC;
.LINE 158

	LD	BC,8
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  159	                        operand->reg_index = R_INDEX_BC;
.LINE 159

	LD	(IY+%3),%0
;  160	                        return;
.LINE 160

	JR	L_177
;  161	                    }
.LINE 161

;  162	                    break;
.LINE 162

;  163	                default:
;  164	                    break;
;  165	            }
;  166	            break;
;  167	        case 'c':
L_75:
.LINE 167

;  168	            switch(tolower(*ptr++)) {
.LINE 168

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFEA),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFEA)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_176
;  169	                case 0:
.LINE 169

;  170	                    operand->reg = R_C;
.LINE 170

	LD	BC,3
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  171	                    operand->reg_index = R_INDEX_C;
.LINE 171

	LD	(IY+%3),%1
;  172	                    operand->cc = true;
.LINE 172

	LD	(IY+%5),%1
;  173	                    operand->cc_index = CC_INDEX_C;
.LINE 173

	LD	(IY+%6),%3
;  174	                    return;
.LINE 174

	JR	L_177
;  175	                default:
;  176	                    break;
;  177	            }
;  178	            break;
;  179	        case 'd':
L_80:
.LINE 179

;  180	            switch(tolower(*ptr++)) {
.LINE 180

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFE7),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFE7)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__39:
	DW	2
	DB	0
	DW24	L_82	

	DB	101
	DW24	L_83	

	DW24	L_176	

;  181	                case 0:
L_82:
.LINE 181

;  182	                    operand->reg = R_D;
.LINE 182

	LD	BC,4
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  183	                    operand->reg_index = R_INDEX_D;
.LINE 183

	LD	(IY+%3),%2
;  184	                    return;
.LINE 184

	JR	L_177
;  185	                case 'e':
L_83:
.LINE 185

;  186	                    switch(tolower(*ptr++)) {
.LINE 186

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFE4),BC
	LD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_176
;  187	                        case 0:
.LINE 187

;  188	                            operand->reg = R_DE;
.LINE 188

	LD	BC,9
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  189	                            operand->reg_index = R_INDEX_DE;
.LINE 189

	LD	(IY+%3),%1
;  190	                            return;
.LINE 190

	JR	L_177
;  191	                        default:
;  192	                            break;
;  193	                    }
;  194	                    break;
;  195	                default:
;  196	                    break;
;  197	            }
;  198	            break;
;  199	        case 'e':
L_90:
.LINE 199

;  200	            switch(tolower(*ptr++)) {
.LINE 200

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFE1),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFE1)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_176
;  201	                case 0:
.LINE 201

;  202	                    operand->reg = R_E;
.LINE 202

	LD	BC,5
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  203	                    operand->reg_index = R_INDEX_E;
.LINE 203

	LD	(IY+%3),%3
;  204	                    return;
.LINE 204

	JR	L_177
;  205	                default:
;  206	                    break;
;  207	            }
;  208	            break;
;  209	        case 'h':
L_95:
.LINE 209

;  210	            switch(tolower(*ptr++)) {
.LINE 210

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFDE),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFDE)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__40:
	DW	2
	DB	0
	DW24	L_97	

	DB	108
	DW24	L_98	

	DW24	L_176	

;  211	                case 0:
L_97:
.LINE 211

;  212	                    operand->reg = R_H;
.LINE 212

	LD	BC,6
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  213	                    operand->reg_index = R_INDEX_H;
.LINE 213

	LD	(IY+%3),%4
;  214	                    return;
.LINE 214

	JR	L_177
;  215	                case 'l':
L_98:
.LINE 215

;  216	                    if(tolower(*ptr == 0)) {
.LINE 216

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L__42
	LD	A,%1
	JR	L__43
L__42:
	XOR	A,A
L__43:
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_tolower
	POP	BC
	CALL	__icmpzero
	JR	Z,L_176
;  217	                        operand->reg = R_HL;
.LINE 217

	LD	BC,10
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  218	                        operand->reg_index = R_INDEX_HL;
.LINE 218

	LD	(IY+%3),%2
;  219	                        return;
.LINE 219

	JR	L_177
;  220	                    }
.LINE 220

;  221	                    break;
.LINE 221

;  222	                default:
;  223	                    break;
;  224	            }
;  225	            break;
;  226	        case 'i':
L_103:
.LINE 226

;  227	            switch(tolower(*ptr++)) {
.LINE 227

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFDB),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFDB)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__45:
	DW	3
	DB	0
	DW24	L_105	

	DB	120
	DW24	L_106	

	DB	121
	DW24	L_120	

	DW24	L_176	

;  228	                case 0:
L_105:
.LINE 228

;  229	                    operand->reg = R_I;
.LINE 229

	LD	BC,21
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  230	                    operand->reg_index = R_INDEX_I;
.LINE 230

	LD	(IY+%3),%0
;  231	                    return;
.LINE 231

	JR	L_177
;  232	                case 'x':
L_106:
.LINE 232

;  233	                    switch(tolower(*ptr++)) {
.LINE 233

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFD8),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFD8)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__46:
	DW	5
	DB	0
	DW24	L_108	

	DB	43
	DW24	L_111	

	DB	45
	DW24	L_112	

	DB	104
	DW24	L_109	

	DB	108
	DW24	L_110	

	DW24	L_176	

;  234	                        case 0:
L_108:
.LINE 234

;  235	                            operand->reg = R_IX;
.LINE 235

	LD	BC,13
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  236	                            operand->reg_index = R_INDEX_IX;
.LINE 236

	LD	(IY+%3),%2
;  237	                            return;
.LINE 237

	JR	L_177
;  238	                        case 'h':
L_109:
.LINE 238

;  239	                            operand->reg = R_IXH;
.LINE 239

	LD	BC,15
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  240	                            return;
.LINE 240

	JR	L_177
;  241	                        case 'l':
L_110:
.LINE 241

;  242	                            operand->reg = R_IXL;
.LINE 242

	LD	BC,16
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  243	                            return;
.LINE 243

	JR	L_177
;  244	                        case '+':
L_111:
.LINE 244

;  245	                        case '-':
L_112:
.LINE 245

;  246	                            if(isdigit(*ptr)) {
.LINE 246

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_isdigit
	POP	BC
	CALL	__icmpzero
	JR	Z,L_176
;  247	                                operand->reg = R_IX;
.LINE 247

	LD	BC,13
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  248	                                operand->displacement_provided = true;
.LINE 248

	LD	(IY+%9),%1
;  249	                                if(*(ptr-1) == '-') operand->displacement = -1 * (int16_t) str2num(ptr,true);
.LINE 249

	LD	HL,(IX+%FFFFFFFD)
	DEC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,45
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_114
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_str2num
	POP	BC
	POP	BC
	CALL	__sneg
	LD	IY,(IX+%9)
	LD	BC,HL
	LD	(IY+%7),C
	LD	(IY+%8),B
;  250	                                else operand->displacement = (int16_t) str2num(ptr,true);
.LINE 250

	JR	L_177
L_114:
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_str2num
	POP	BC
	POP	BC
	LD	IY,(IX+%9)
	LD	BC,HL
	LD	(IY+%7),C
	LD	(IY+%8),B
;  251	                                return;
.LINE 251

	JR	L_177
;  252	                            }
.LINE 252

;  253	                            break;
.LINE 253

;  254	                        default:
;  255	                            break;
;  256	                    }
;  257	                    break;
;  258	                case 'y':
L_120:
.LINE 258

;  259	                    switch(tolower(*ptr++)) {
.LINE 259

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFD5),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFD5)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__49:
	DW	5
	DB	0
	DW24	L_122	

	DB	43
	DW24	L_125	

	DB	45
	DW24	L_126	

	DB	104
	DW24	L_123	

	DB	108
	DW24	L_124	

	DW24	L_176	

;  260	                        case 0:
L_122:
.LINE 260

;  261	                            operand->reg = R_IY;
.LINE 261

	LD	BC,14
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  262	                            operand->reg_index = R_INDEX_IY;
.LINE 262

	LD	(IY+%3),%2
;  263	                            return;
.LINE 263

	JR	L_177
;  264	                        case 'h':
L_123:
.LINE 264

;  265	                            operand->reg = R_IYH;
.LINE 265

	LD	BC,17
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  266	                            return;
.LINE 266

	JR	L_177
;  267	                        case 'l':
L_124:
.LINE 267

;  268	                            operand->reg = R_IYL;
.LINE 268

	LD	BC,18
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  269	                            return;
.LINE 269

	JR	L_177
;  270	                        case '+':
L_125:
.LINE 270

;  271	                        case '-':
L_126:
.LINE 271

;  272	                            if(isdigit(*ptr)) {
.LINE 272

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_isdigit
	POP	BC
	CALL	__icmpzero
	JR	Z,L_176
;  273	                                operand->reg = R_IY;
.LINE 273

	LD	BC,14
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  274	                                operand->displacement_provided = true;
.LINE 274

	LD	(IY+%9),%1
;  275	                                if(*(ptr-1) == '-') operand->displacement = -1 * (int16_t) str2num(ptr,true);
.LINE 275

	LD	HL,(IX+%FFFFFFFD)
	DEC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,45
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_128
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_str2num
	POP	BC
	POP	BC
	CALL	__sneg
	LD	IY,(IX+%9)
	LD	BC,HL
	LD	(IY+%7),C
	LD	(IY+%8),B
;  276	                                else operand->displacement = (int16_t) str2num(ptr,true);
.LINE 276

	JR	L_177
L_128:
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_str2num
	POP	BC
	POP	BC
	LD	IY,(IX+%9)
	LD	BC,HL
	LD	(IY+%7),C
	LD	(IY+%8),B
;  277	                                return;
.LINE 277

	JR	L_177
;  278	                            }
.LINE 278

;  279	                            break;
.LINE 279

;  280	                        default:
;  281	                            break;
;  282	                    }
;  283	                    break;
;  284	                default:
;  285	                    break;
;  286	            }
;  287	            break;
;  288	        case 'l':
L_136:
.LINE 288

;  289	            switch(tolower(*ptr++)) {
.LINE 289

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFD2),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFD2)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_176
;  290	                case 0:
.LINE 290

;  291	                    operand->reg = R_L;
.LINE 291

	LD	BC,7
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  292	                    operand->reg_index = R_INDEX_L;
.LINE 292

	LD	(IY+%3),%5
;  293	                    return;
.LINE 293

	JR	L_177
;  294	                default:
;  295	                    break;
;  296	            }
;  297	            break;
;  298	        case 'm':
L_141:
.LINE 298

;  299	            if((tolower(*ptr) == 'b') && ptr[1] == 0) {
.LINE 299

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	LD	BC,98
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_145
	LD	HL,(IX+%FFFFFFFD)
	INC	HL
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_145
;  300	                operand->reg = R_MB;
.LINE 300

	LD	BC,20
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  301	                operand->reg_index = R_INDEX_MB;
.LINE 301

	LD	(IY+%3),%0
;  302	                return;
.LINE 302

	JR	L_177
;  303	            }
L_145:
.LINE 303

;  304	            if((*ptr == 0)) {
.LINE 304

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_176
;  305	                operand->cc = true;
.LINE 305

	LD	IY,(IX+%9)
	LD	(IY+%5),%1
;  306	                operand->cc_index = CC_INDEX_M;
.LINE 306

	LD	(IY+%6),%7
;  307	                return;
.LINE 307

	JR	L_177
;  308	            }
.LINE 308

;  309	            break;
.LINE 309

;  310	        case 'n':
L_147:
.LINE 310

;  311	            switch(tolower(*ptr++)) {
.LINE 311

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFCF),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFCF)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__55:
	DW	2
	DB	99
	DW24	L_149	

	DB	122
	DW24	L_150	

	DW24	L_176	

;  312	                case 'c':   // NC
L_149:
.LINE 312

;  313	                    operand->cc = true;
.LINE 313

	LD	IY,(IX+%9)
	LD	(IY+%5),%1
;  314	                    operand->cc_index = CC_INDEX_NC;
.LINE 314

	LD	(IY+%6),%2
;  315	                    return;
.LINE 315

	JR	L_177
;  316	                case 'z':   // NZ
L_150:
.LINE 316

;  317	                    operand->cc = true;
.LINE 317

	LD	IY,(IX+%9)
	LD	(IY+%5),%1
;  318	                    operand->cc_index = CC_INDEX_NZ;
.LINE 318

	LD	(IY+%6),%0
;  319	                    return;
.LINE 319

	JR	L_177
;  320	                default:
;  321	                    break;
;  322	            }
;  323	            break;
;  324	        case 'p':
L_153:
.LINE 324

;  325	            switch(tolower(*ptr++)) {
.LINE 325

	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFCC),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	HL,(IX+%FFFFFFCC)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__56:
	DW	3
	DB	0
	DW24	L_155	

	DB	101
	DW24	L_156	

	DB	111
	DW24	L_157	

	DW24	L_176	

;  326	                case 0:
L_155:
.LINE 326

;  327	                    operand->cc = true;
.LINE 327

	LD	IY,(IX+%9)
	LD	(IY+%5),%1
;  328	                    operand->cc_index = CC_INDEX_P;
.LINE 328

	LD	(IY+%6),%6
;  329	                    return;
.LINE 329

	JR	L_177
;  330	                case 'e':
L_156:
.LINE 330

;  331	                    operand->cc = true;
.LINE 331

	LD	IY,(IX+%9)
	LD	(IY+%5),%1
;  332	                    operand->cc_index = CC_INDEX_PE;
.LINE 332

	LD	(IY+%6),%5
;  333	                    return;
.LINE 333

	JR	L_177
;  334	                case 'o':
L_157:
.LINE 334

;  335	                    operand->cc = true;
.LINE 335

	LD	IY,(IX+%9)
	LD	(IY+%5),%1
;  336	                    operand->cc_index = CC_INDEX_PO;
.LINE 336

	LD	(IY+%6),%4
;  337	                    return;
.LINE 337

	JR	L_177
;  338	                default:
;  339	                    break;
;  340	            }
;  341	            break;
;  342	        case 'r':
L_160:
.LINE 342

;  343	            if(*ptr == 0) {
.LINE 343

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_176
;  344	                operand->reg = R_R;
.LINE 344

	LD	BC,19
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  345	                operand->reg_index = R_INDEX_R;
.LINE 345

	LD	(IY+%3),%0
;  346	                return;
.LINE 346

	JR	L_177
;  347	            }
.LINE 347

;  348	            break;
.LINE 348

;  349	        case 's':
L_163:
.LINE 349

;  350	            if((tolower(*ptr) == 'p') && ptr[1] == 0) {
.LINE 350

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	LD	BC,112
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_176
	LD	HL,(IX+%FFFFFFFD)
	INC	HL
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_176
;  351	                operand->reg = R_SP;
.LINE 351

	LD	BC,11
	LD	IY,(IX+%9)
	LD	(IY+%0),BC
;  352	                operand->reg_index = R_INDEX_SP;
.LINE 352

	LD	(IY+%3),%3
;  353	                return;
.LINE 353

	JR	L_177
;  354	            }
.LINE 354

;  355	            break;
.LINE 355

;  356	        case 'z':
L_167:
.LINE 356

;  357	            if(*ptr == 0) {
.LINE 357

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_176
;  358	                operand->cc = true;
.LINE 358

	LD	A,%1
	LD	IY,(IX+%9)
	LD	(IY+%5),A
;  359	                operand->cc_index = CC_INDEX_Z;
.LINE 359

	LD	(IY+%6),A
;  360	                return;
.LINE 360

	JR	L_177
;  361	            }
.LINE 361

;  362	            break;
;  363	        default:
;  364	            break;
;  365	    }
L_176:
.LINE 365

;  366	    if(*string) {
.LINE 366

	LD	HL,(IX+%6)
	LD	A,(HL)
	OR	A,A
	JR	Z,L_177
;  367	        if(operand->indirect) operand->immediate = getLabelValue(string + 1);
.LINE 367

	LD	IY,(IX+%9)
	LD	A,(IY+%4)
	OR	A,A
	JR	Z,L_173
	LD	BC,(IX+%6)
	INC	BC
	PUSH	BC
	CALL	_getLabelValue
	POP	BC
	LD	IY,(IX+%9)
	LD	(IY+%B),HL
	LD	(IY+%E),E
;  368	        else operand->immediate = getLabelValue(string);
.LINE 368

	JR	L_174
L_173:
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_getLabelValue
	POP	BC
	LD	IY,(IX+%9)
	LD	(IY+%B),HL
	LD	(IY+%E),E
L_174:
;  369	        operand->immediate_provided = true;
.LINE 369

	LD	A,%1
	LD	IY,(IX+%9)
	LD	(IY+%A),A
;  370	        operand->wasLabel = true;
.LINE 370

	LD	(IY+%F),A
;  371	    }
;  372	}
L_177:
.LINE 372

	LD	SP,IX
	POP	IX
	RET	


;**************************** _parse_operand ***************************
;Name                         Addr/Register   Size   Type
;_str2num                            IMPORT  -----   function
;_isdigit                            IMPORT  -----   function
;_tolower                            IMPORT  -----   function
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;G_3                                   IX-7      3   variable
;len                                   IX-4      1   variable
;ptr                                   IX-3      3   variable
;operand                               IX+9      3   parameter
;string                                IX+6      3   parameter


; Stack Frame Size: 64 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "parse_operand",372,"_parse_operand"
;  373	
;  374	void parseLine(char *src) {
_parseLine:
.DEFINE "_parseLine"

.VALUE _parseLine

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "parseLine",374,"_parseLine"

.LINE 374

.DEFINE "src"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "state"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "argcount"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

.DEFINE "x"

.CLASS 65

.VALUE -3

.TYPE 12

.ENDEF

.DEFINE "done"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "token"

.CLASS 65

.VALUE -268

.TAG "NONAME11"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-268
	ADD	HL,SP
	LD	SP,HL
;  375	    uint8_t x;
;  376	    bool done;
;  377	    uint8_t state;
;  378	    uint8_t argcount = 0;
.LINE 378

	LD	(IX+%FFFFFFFE),%0
;  379	    tokentype token;
;  380	
;  381	    // default current line items
;  382	    currentline.current_instruction = NULL;
.LINE 382

	LD	BC,0
	LD	(_currentline),BC
;  383	    currentline.next = NULL;
.LINE 383

	LD	(_currentline+3),BC
;  384	    currentline.label[0] = 0;
.LINE 384

	XOR	A,A
	LD	(_currentline+6),A
;  385	    currentline.mnemonic[0] = 0;
.LINE 385

	XOR	A,A
	LD	(_currentline+38),A
;  386	    currentline.suffix[0] = 0;
.LINE 386

	XOR	A,A
	LD	(_currentline+54),A
;  387	    currentline.operand1[0] = 0;
.LINE 387

	XOR	A,A
	LD	(_currentline+70),A
;  388	    currentline.operand2[0] = 0;
.LINE 388

	XOR	A,A
	LD	(_currentline+102),A
;  389	    currentline.comment[0] = 0;
.LINE 389

	XOR	A,A
	LD	(_currentline+134),A
;  390	    currentline.size = 0;
.LINE 390

	LD	HL,_currentline+262
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
;  391	
;  392	    empty_operand(&operand1);
.LINE 392

	LD	BC,_operand1
	PUSH	BC
	CALL	_empty_operand
	POP	BC
;  393	    empty_operand(&operand2);
.LINE 393

	LD	BC,_operand2
	PUSH	BC
	CALL	_empty_operand
	POP	BC
;  394	
;  395	    state = PS_START;
.LINE 395

	LD	(IX+%FFFFFFFF),%0
;  396	    done = false;
.LINE 396

	LD	(IX+%FFFFFFFC),%0
;  397	    while(!done) {
.LINE 397

	JR	L_227
L_228:
;  398	        switch(state) {
.LINE 398

	LD	A,(IX+%FFFFFFFF)
	UEXT	HL
	LD	L,A
	CALL	__seqcaseD
	JP	(HL)
L__64:
	DW	8
	DW	0
	DB	0
	DW24	L_178	

	DW24	L_192	

	DW24	L_199	

	DW24	L_213	

	DW24	L_227	

	DW24	L_224	

	DW24	L_226	

	DW24	L_225	

	DW24	L_227	

;  399	            case PS_START:
L_178:
.LINE 399

;  400	                if((isspace(*src) == 0) && (*src) != '.') {
.LINE 400

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_isspace
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_185
	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	Z,L_185
;  401	                    getLineToken(&token, src, ':');
.LINE 401

	LD	BC,58
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	LD	HL,IX
	LD	BC,-268
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
;  402	                    switch(token.terminator) {
.LINE 402

	LD	A,(IX+%FFFFFFF8)
	SEXT	HL
	LD	L,(IX+%FFFFFFF8)
	CALL	__case8D
	JP	(HL)
L__67:
	DW	2
	DB	58
	DW24	L_180	

	DB	59
	DW24	L_181	

	DW24	L_182	

;  403	                        case ':':
L_180:
.LINE 403

;  404	                            state = PS_LABEL;
.LINE 404

	LD	(IX+%FFFFFFFF),%1
;  405	                            break;
.LINE 405

	JR	L_227
;  406	                        case ';':
L_181:
.LINE 406

;  407	                            state = PS_COMMENT;
.LINE 407

	LD	(IX+%FFFFFFFF),%5
;  408	                            break;
.LINE 408

	JR	L_227
;  409	                        default:
L_182:
.LINE 409

;  410	                            error(message[ERROR_INVALIDLABEL]);
.LINE 410

	LD	HL,_message+12
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  411	                            state = PS_ERROR;                        
.LINE 411

	LD	(IX+%FFFFFFFF),%7
;  412	                            break;
.LINE 412

	JR	L_227
;  413	                    }
;  414	                    break;
;  415	                }
L_185:
.LINE 415

;  416	                x = getLineToken(&token, src,' ');
.LINE 416

	LD	BC,32
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	LD	HL,IX
	LD	BC,-268
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),A
;  417	                if(x) state = PS_COMMAND;
.LINE 417

	OR	A,A
	JR	Z,L_190
	LD	(IX+%FFFFFFFF),%2
;  418	                else {
.LINE 418

	JR	L_227
L_190:
;  419	                    if(token.terminator == 0) {
.LINE 419

	LD	A,(IX+%FFFFFFF8)
	OR	A,A
	JR	NZ,L_188
;  420	                        state = PS_DONE;
.LINE 420

	LD	(IX+%FFFFFFFF),%6
;  421	                        break;
.LINE 421

	JR	L_227
;  422	                    }
L_188:
.LINE 422

;  423	                    if(token.terminator == ';') {
.LINE 423

	LD	A,(IX+%FFFFFFF8)
	CP	A,%3B
	JR	NZ,L_227
;  424	                        state = PS_COMMENT;
.LINE 424

	LD	(IX+%FFFFFFFF),%5
;  425	                        break;
.LINE 425

	JR	L_227
;  426	                    }
;  427	                }
.LINE 427

;  428	                break;
.LINE 428

;  429	            case PS_LABEL:
L_192:
.LINE 429

;  430	                strcpy(currentline.label,token.start);
.LINE 430

	LD	HL,IX
	LD	BC,-268
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	BC,_currentline+6
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  431	                advanceLocalLabel();
.LINE 431

	CALL	_advanceLocalLabel
;  432	                x = getLineToken(&token, token.next, ' ');
.LINE 432

	LD	BC,32
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	HL,IX
	LD	BC,-268
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFD),A
;  433	                if(x) state = PS_COMMAND;
.LINE 433

	OR	A,A
	JR	Z,L_197
	LD	(IX+%FFFFFFFF),%2
;  434	                else {
.LINE 434

	JR	L_227
L_197:
;  435	                    if(token.terminator == 0) {
.LINE 435

	LD	A,(IX+%FFFFFFF8)
	OR	A,A
	JR	NZ,L_195
;  436	                        state = PS_DONE;
.LINE 436

	LD	(IX+%FFFFFFFF),%6
;  437	                        break;
.LINE 437

	JR	L_227
;  438	                    }
L_195:
.LINE 438

;  439	                    if(token.terminator == ';') {
.LINE 439

	LD	A,(IX+%FFFFFFF8)
	CP	A,%3B
	JR	NZ,L_227
;  440	                        state = PS_COMMENT;
.LINE 440

	LD	(IX+%FFFFFFFF),%5
;  441	                        break;
.LINE 441

	JR	L_227
;  442	                    }
;  443	                }
.LINE 443

;  444	                break;
.LINE 444

;  445	            case PS_COMMAND:
L_199:
.LINE 445

;  446	                if(token.start[0] == '.') strcpy(currentline.mnemonic, token.start+1);
.LINE 446

	LD	HL,IX
	LD	BC,-268
	ADD	HL,BC
	LD	(IX+%FFFFFFF9),HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_201
	LD	BC,(IX+%FFFFFFF9)
	INC	BC
	PUSH	BC
	LD	BC,_currentline+38
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  447	                else split_suffix(currentline.mnemonic, currentline.suffix, token.start);
.LINE 447

	JR	L_202
L_201:
	LD	BC,(IX+%FFFFFFF9)
	PUSH	BC
	LD	BC,_currentline+54
	PUSH	BC
	LD	BC,_currentline+38
	PUSH	BC
	CALL	_split_suffix
	POP	BC
	POP	BC
	POP	BC
L_202:
;  448	
;  449	                currentline.current_instruction = instruction_table_lookup(currentline.mnemonic);
.LINE 449

	LD	BC,_currentline+38
	PUSH	BC
	CALL	_instruction_table_lookup
	POP	BC
	LD	(_currentline),HL
;  450	                if(currentline.current_instruction == NULL) {
.LINE 450

	CALL	__icmpzero
	JR	NZ,L_205
;  451	                    error(message[ERROR_INVALIDMNEMONIC]);
.LINE 451

	LD	HL,_message+18
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  452	                    state = PS_ERROR;
.LINE 452

	LD	(IX+%FFFFFFFF),%7
;  453	                    break;
.LINE 453

	JR	L_227
;  454	                }
L_205:
.LINE 454

;  455	                if(currentline.current_instruction->type == ASSEMBLER) {
.LINE 455

	LD	IY,(_currentline)
	LD	A,(IY+%8)
	CP	A,%1
	JR	NZ,L_207
;  456	                    currentline.next = token.next;
.LINE 456

	LD	BC,(IX+%FFFFFFF5)
	LD	(_currentline+3),BC
;  457	                    state = PS_DONE;
.LINE 457

	LD	(IX+%FFFFFFFF),%6
;  458	                    break;
.LINE 458

	JR	L_227
;  459	                }
L_207:
.LINE 459

;  460	                if(token.start[0] == '.') {
.LINE 460

	LD	HL,-268
	LD	BC,IX
	ADD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,46
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_211
;  461	                    error(message[ERROR_INVALIDMNEMONIC]);
.LINE 461

	LD	HL,_message+18
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  462	                    currentline.mnemonic[0] = 0;
.LINE 462

	XOR	A,A
	LD	(_currentline+38),A
;  463	                    state = PS_ERROR;                    
.LINE 463

	LD	(IX+%FFFFFFFF),%7
;  464	                    break;
.LINE 464

	JR	L_227
;  465	                }
L_211:
.LINE 465

;  466	                // Valid EZ80 instruction
;  467	                switch(token.terminator) {
.LINE 467

	LD	A,(IX+%FFFFFFF8)
	SEXT	HL
	LD	L,(IX+%FFFFFFF8)
	CALL	__case8D
	JP	(HL)
L__78:
	DW	2
	DB	0
	DW24	L_209	

	DB	59
	DW24	L_208	

	DW24	L_210	

;  468	                    case ';':
L_208:
.LINE 468

;  469	                        getLineToken(&token, token.next, 0);
.LINE 469

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	HL,IX
	LD	BC,-268
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
;  470	                        state = PS_COMMENT;
.LINE 470

	LD	(IX+%FFFFFFFF),%5
;  471	                        break;
.LINE 471

	JR	L_227
;  472	                    case 0:
L_209:
.LINE 472

;  473	                        currentline.next = NULL;
.LINE 473

	LD	BC,0
	LD	(_currentline+3),BC
;  474	                        state = PS_DONE;
.LINE 474

	LD	(IX+%FFFFFFFF),%6
;  475	                        break;
.LINE 475

	JR	L_227
;  476	                    default:
L_210:
.LINE 476

;  477	                        getLineToken(&token, token.next, ',');
.LINE 477

	LD	BC,44
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	HL,IX
	LD	BC,-268
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
;  478	                        state = PS_OP1;
.LINE 478

	LD	(IX+%FFFFFFFF),%3
;  479	                        break;
.LINE 479

	JR	L_227
;  480	                }                
;  481	                break;
;  482	            case PS_OP1:
L_213:
.LINE 482

;  483	                argcount++;
.LINE 483

	INC	(IX+%FFFFFFFE)
;  484	                if(argcount == 1) {
.LINE 484

	LD	A,(IX+%FFFFFFFE)
	CP	A,%1
	JR	NZ,L_216
;  485	                    strcpy(currentline.operand1, token.start);
.LINE 485

	LD	HL,IX
	LD	BC,-268
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	BC,_currentline+70
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  486	                    parse_operand(currentline.operand1, &operand1);
.LINE 486

	LD	BC,_operand1
	PUSH	BC
	LD	BC,_currentline+70
	PUSH	BC
	CALL	_parse_operand
	POP	BC
	POP	BC
;  487	                }
;  488	                else {
.LINE 488

	JR	L_222
L_216:
;  489	                    strcpy(currentline.operand2, token.start);
.LINE 489

	LD	HL,IX
	LD	BC,-268
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	BC,_currentline+102
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  490	                    parse_operand(currentline.operand2, &operand2);
.LINE 490

	LD	BC,_operand2
	PUSH	BC
	LD	BC,_currentline+102
	PUSH	BC
	CALL	_parse_operand
	POP	BC
	POP	BC
;  491	                }
L_222:
.LINE 491

;  492	                switch(token.terminator) {
.LINE 492

	LD	A,(IX+%FFFFFFF8)
	SEXT	HL
	LD	L,(IX+%FFFFFFF8)
	CALL	__case8D
	JP	(HL)
L__80:
	DW	3
	DB	0
	DW24	L_218	

	DB	44
	DW24	L_219	

	DB	59
	DW24	L_217	

	DW24	L_227	

;  493	                    case ';':
L_217:
.LINE 493

;  494	                        getLineToken(&token, token.next, 0);
.LINE 494

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	HL,IX
	LD	BC,-268
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
;  495	                        state = PS_COMMENT;
.LINE 495

	LD	(IX+%FFFFFFFF),%5
;  496	                        break;
.LINE 496

	JR	L_227
;  497	                    case 0:
L_218:
.LINE 497

;  498	                        currentline.next = NULL;
.LINE 498

	LD	BC,0
	LD	(_currentline+3),BC
;  499	                        state = PS_DONE;
.LINE 499

	LD	(IX+%FFFFFFFF),%6
;  500	                        break;
.LINE 500

	JR	L_227
;  501	                    case ',':
L_219:
.LINE 501

;  502	                        if(argcount == 2) {
.LINE 502

	LD	A,(IX+%FFFFFFFE)
	CP	A,%2
	JR	NZ,L_221
;  503	                            error(message[ERROR_TOOMANYARGUMENTS]);
.LINE 503

	LD	HL,_message+87
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  504	                            state = PS_ERROR;
.LINE 504

	LD	(IX+%FFFFFFFF),%7
;  505	                            break;
.LINE 505

	JR	L_227
;  506	                        }
L_221:
.LINE 506

;  507	                        getLineToken(&token, token.next, ',');
.LINE 507

	LD	BC,44
	PUSH	BC
	LD	BC,(IX+%FFFFFFF5)
	PUSH	BC
	LD	HL,IX
	LD	BC,-268
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
;  508	                        break;
.LINE 508

	JR	L_227
;  509	                }
;  510	                break;
;  511	            case PS_COMMENT:
L_224:
.LINE 511

;  512	                strcpy(currentline.comment,token.start);
.LINE 512

	LD	HL,IX
	LD	BC,-268
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	BC,_currentline+134
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  513	                state = PS_DONE;
.LINE 513

	LD	(IX+%FFFFFFFF),%6
;  514	                break;
.LINE 514

	JR	L_227
;  515	            case PS_ERROR:
L_225:
.LINE 515

;  516	                //error(message[ERROR_PARSE]);
;  517	                currentline.next = NULL;
.LINE 517

	LD	BC,0
	LD	(_currentline+3),BC
;  518	                state = PS_DONE;
.LINE 518

	LD	(IX+%FFFFFFFF),%6
;  519	                break;
.LINE 519

	JR	L_227
;  520	            case PS_DONE:
L_226:
.LINE 520

;  521	                done = true;
.LINE 521

	LD	(IX+%FFFFFFFC),%1
;  522	                break;
;  523	        }
;  524	    }
L_227:
.LINE 524

	LD	A,(IX+%FFFFFFFC)
	OR	A,A
	JR	Z,L_228
;  525	}
.LINE 525

	LD	SP,IX
	POP	IX
	RET	


;**************************** _parseLine ***************************
;Name                         Addr/Register   Size   Type
;_instruction_table_lookup           IMPORT  -----   function
;_split_suffix                       IMPORT  -----   function
;_strcpy                             IMPORT  -----   function
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_getLineToken                       IMPORT  -----   function
;_isspace                            IMPORT  -----   function
;_operand2                           IMPORT     16   variable
;_operand1                           IMPORT     16   variable
;_currentline                        IMPORT    264   variable
;token                               IX-268    261   variable
;G_4                                   IX-7      3   variable
;done                                  IX-4      1   variable
;x                                     IX-3      1   variable
;argcount                              IX-2      1   variable
;state                                 IX-1      1   variable
;src                                   IX+6      3   parameter


; Stack Frame Size: 277 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "parseLine",525,"_parseLine"
;  526	
;  527	void definelabel(int32_t num){
_definelabel:
.DEFINE "_definelabel"

.VALUE _definelabel

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "definelabel",527,"_definelabel"

.LINE 527

.DEFINE "num"

.CLASS 65

.VALUE 6

.TYPE 5

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;  528	    if(strlen(currentline.label)) {
.LINE 528

	LD	BC,_currentline+6
	PUSH	BC
	CALL	_strlen
	POP	BC
	CALL	__icmpzero
	JR	Z,L_238
;  529	        if(currentline.label[0] == '@') {
.LINE 529

	LD	BC,_currentline+6
	LD	(IX+%FFFFFFFD),BC
	LD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,64
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_236
;  530	            if(currentline.label[1] == '@') {
.LINE 530

	LD	HL,(IX+%FFFFFFFD)
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,64
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_232
;  531	                writeAnonymousLabel(num);
.LINE 531

	LD	C,(IX+%9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_writeAnonymousLabel
	POP	BC
	POP	BC
;  532	                return;
.LINE 532

	JR	L_238
;  533	            }
L_232:
.LINE 533

;  534	            if(insertLocalLabel(currentline.label, num) == false) {
.LINE 534

	LD	C,(IX+%9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_insertLocalLabel
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_238
;  535	                error(message[ERROR_CREATINGLABEL]);
.LINE 535

	LD	HL,_message+93
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  536	                return;
.LINE 536

	JR	L_238
;  537	            }
;  538	        }
;  539	        else {
L_236:
.LINE 539

;  540	            if(insertGlobalLabel(currentline.label, num) == false){
.LINE 540

	LD	C,(IX+%9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_insertGlobalLabel
	POP	BC
	POP	BC
	POP	BC
	OR	A,A
	JR	NZ,L_234
;  541	                error(message[ERROR_CREATINGLABEL]);
.LINE 541

	LD	HL,_message+93
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  542	                return;
.LINE 542

	JR	L_238
;  543	            }
L_234:
.LINE 543

;  544	            writeLocalLabels();
.LINE 544

	CALL	_writeLocalLabels
;  545	            clearLocalLabels();
.LINE 545

	CALL	_clearLocalLabels
;  546	        }
;  547	    }
;  548	}
L_238:
.LINE 548

	LD	SP,IX
	POP	IX
	RET	


;**************************** _definelabel ***************************
;Name                         Addr/Register   Size   Type
;_clearLocalLabels                   IMPORT  -----   function
;_writeLocalLabels                   IMPORT  -----   function
;_insertGlobalLabel                  IMPORT  -----   function
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_insertLocalLabel                   IMPORT  -----   function
;_writeAnonymousLabel                IMPORT  -----   function
;_currentline                        IMPORT    264   variable
;_strlen                             IMPORT  -----   function
;G_6                                   IX-3      3   variable
;num                                   IX+6      4   parameter


; Stack Frame Size: 15 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "definelabel",548,"_definelabel"
;  549	
;  550	void refreshlocalLabels(void) {
_refreshlocalLabels:
.DEFINE "_refreshlocalLabels"

.VALUE _refreshlocalLabels

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "refreshlocalLabels",550,"_refreshlocalLabels"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  551	    if(pass == 2) {
.LINE 551

	LD	BC,2
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_242
;  552	        if(notEmpty(currentline.label)) {
.LINE 552

	LD	BC,_currentline+6
	PUSH	BC
	CALL	_notEmpty
	POP	BC
	OR	A,A
	JR	Z,L_242
;  553	            if(currentline.label[0] != '@') {
.LINE 553

	LD	A,(_currentline+6)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,64
	OR	A,A
	SBC	HL,BC
	JR	Z,L_242
;  554	                clearLocalLabels();
.LINE 554

	CALL	_clearLocalLabels
;  555	                readLocalLabels();
.LINE 555

	CALL	_readLocalLabels
;  556	            }
;  557	        }
;  558	    }
;  559	}
L_242:
.LINE 559

	LD	SP,IX
	POP	IX
	RET	


;**************************** _refreshlocalLabels ***************************
;Name                         Addr/Register   Size   Type
;_readLocalLabels                    IMPORT  -----   function
;_clearLocalLabels                   IMPORT  -----   function
;_currentline                        IMPORT    264   variable
;_notEmpty                           IMPORT  -----   function
;_pass                               IMPORT      3   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "refreshlocalLabels",559,"_refreshlocalLabels"
;  560	
;  561	// return ADL prefix bitfield, or 0 if none present
;  562	uint8_t getADLsuffix(void) {
_getADLsuffix:
.DEFINE "_getADLsuffix"

.VALUE _getADLsuffix

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "getADLsuffix",562,"_getADLsuffix"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
;  563	    if(notEmpty(currentline.suffix)) {
.LINE 563

	LD	BC,_currentline+54
	PUSH	BC
	CALL	_notEmpty
	POP	BC
	OR	A,A
	JR	Z,L_285
;  564	        switch(strlen(currentline.suffix)) {
.LINE 564

	LD	BC,_currentline+54
	PUSH	BC
	CALL	_strlen
	POP	BC
	CALL	__seqcaseD
	JP	(HL)
L__95:
	DW	3
	DW	1
	DB	0
	DW24	L_243	

	DW24	L_254	

	DW24	L_267	

	DW24	L_283	

;  565	            case 1: // .s or .l
L_243:
.LINE 565

;  566	                switch(tolower(currentline.suffix[0])) {
.LINE 566

	LD	A,(_currentline+54)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__96:
	DW	2
	DB	108
	DW24	L_248	

	DB	115
	DW24	L_244	

	DW24	L_283	

;  567	                    case 's':
L_244:
.LINE 567

;  568	                        if(adlmode) return S_SIL;  // SIL
.LINE 568

	LD	A,(_adlmode)
	OR	A,A
	JR	Z,L_246
	LD	A,%4
	JR	L_286
;  569	                        else return S_SIS;         // SIS
L_246:
.LINE 569

	LD	A,%1
	JR	L_286
;  570	                        break;
;  571	                    case 'l':
L_248:
.LINE 571

;  572	                        if(adlmode) return S_LIL;  // LIL
.LINE 572

	LD	A,(_adlmode)
	OR	A,A
	JR	Z,L_250
	LD	A,%8
	JR	L_286
;  573	                        else return S_LIS;         // LIS
L_250:
.LINE 573

	LD	A,%2
	JR	L_286
;  574	                        break;
;  575	                    default: // illegal suffix
;  576	                        break;
;  577	                }
;  578	                break;
;  579	            case 2: // .is or .il
L_254:
.LINE 579

;  580	                if(tolower(currentline.suffix[0]) != 'i') break; // illegal suffix
.LINE 580

	LD	BC,_currentline+54
	LD	(IX+%FFFFFFFA),BC
	LD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	LD	BC,105
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_283
;  581	                switch(tolower(currentline.suffix[1])) {
.LINE 581

	LD	HL,(IX+%FFFFFFFA)
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__100:
	DW	2
	DB	108
	DW24	L_260	

	DB	115
	DW24	L_256	

	DW24	L_283	

;  582	                    case 's':
L_256:
.LINE 582

;  583	                        if(adlmode) return S_LIS;  // LIS
.LINE 583

	LD	A,(_adlmode)
	OR	A,A
	JR	Z,L_258
	LD	A,%2
	JR	L_286
;  584	                        else return S_SIS;         // SIS
L_258:
.LINE 584

	LD	A,%1
	JR	L_286
;  585	                        break;
;  586	                    case 'l':
L_260:
.LINE 586

;  587	                        if(adlmode) return S_LIL;  // LIL
.LINE 587

	LD	A,(_adlmode)
	OR	A,A
	JR	Z,L_262
	LD	A,%8
	JR	L_286
;  588	                        else return S_SIL;         // SIL
L_262:
.LINE 588

	LD	A,%4
	JR	L_286
;  589	                        break;
;  590	                    default: // illegal suffix
;  591	                        break;
;  592	                }
;  593	                break;
;  594	            case 3:
L_267:
.LINE 594

;  595	                if(tolower(currentline.suffix[1]) != 'i') break; // illegal suffix
.LINE 595

	LD	BC,_currentline+54
	LD	(IX+%FFFFFFFD),BC
	LD	HL,BC
	INC	HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	LD	BC,105
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_283
;  596	                switch(tolower(currentline.suffix[0])) {
.LINE 596

	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	PUSH	HL
	CALL	_tolower
	POP	BC
	CALL	__case8D
	JP	(HL)
L__104:
	DW	2
	DB	108
	DW24	L_274	

	DB	115
	DW24	L_269	

	DW24	L_283	

;  597	                    case 's':
L_269:
.LINE 597

;  598	                        if(currentline.suffix[2] == 's') return S_SIS; // SIS
.LINE 598

	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%2
	LD	(IX+%FFFFFFF7),IY
	LD	HL,(IX+%FFFFFFF7)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,115
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_272
	LD	A,%1
	JR	L_286
L_272:
;  599	                        if(currentline.suffix[2] == 'l') return S_SIL; // SIL
.LINE 599

	LD	HL,(IX+%FFFFFFF7)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,108
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_283
	LD	A,%4
	JR	L_286
;  600	                        // illegal suffix
;  601	                        break;
.LINE 601

;  602	                    case 'l':
L_274:
.LINE 602

;  603	                        if(currentline.suffix[2] == 's') return S_LIS; // LIS
.LINE 603

	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%2
	LD	(IX+%FFFFFFF4),IY
	LD	HL,(IX+%FFFFFFF4)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,115
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_277
	LD	A,%2
	JR	L_286
L_277:
;  604	                        if(currentline.suffix[2] == 'l') return S_LIL; // LIL
.LINE 604

	LD	HL,(IX+%FFFFFFF4)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,108
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_283
	LD	A,%8
	JR	L_286
;  605	                        // illegal suffix
;  606	                        break;
;  607	                    default: // illegal suffix
;  608	                        break;
;  609	                }
;  610	                break;
;  611	            default: // illegal suffix
;  612	                break;
;  613	        }
L_283:
.LINE 613

;  614	        error(message[ERROR_INVALIDSUFFIX]);
.LINE 614

	LD	HL,_message+36
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  615	    }
L_285:
.LINE 615

;  616	    return 0;
.LINE 616

	XOR	A,A
;  617	}
L_286:
.LINE 617

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getADLsuffix ***************************
;Name                         Addr/Register   Size   Type
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_adlmode                            IMPORT      1   variable
;_tolower                            IMPORT  -----   function
;_strlen                             IMPORT  -----   function
;_currentline                        IMPORT    264   variable
;_notEmpty                           IMPORT  -----   function
;G_14                                 IX-12      3   variable
;G_12                                  IX-9      3   variable
;G_9                                   IX-6      3   variable
;G_10                                  IX-3      3   variable


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getADLsuffix",617,"_getADLsuffix"
;  618	
;  619	void adl_action() {
_adl_action:
.DEFINE "_adl_action"

.VALUE _adl_action

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "adl_action",619,"_adl_action"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  620	    if(strcmp(currentline.operand1, "0") == 0) adlmode = false;
.LINE 620

	LD	BC,L__110
	PUSH	BC
	LD	BC,_currentline+70
	PUSH	BC
	CALL	_strcmp
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_289
	XOR	A,A
	LD	(_adlmode),A
L_289:
;  621	    if(strcmp(currentline.operand1, "1") == 0) adlmode = true;
.LINE 621

	LD	BC,L__112
	PUSH	BC
	LD	BC,_currentline+70
	PUSH	BC
	CALL	_strcmp
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_290
	LD	A,%1
	LD	(_adlmode),A
;  622	}
L_290:
.LINE 622

	LD	SP,IX
	POP	IX
	RET	


;**************************** _adl_action ***************************
;Name                         Addr/Register   Size   Type
;_adlmode                            IMPORT      1   variable
;_currentline                        IMPORT    264   variable
;_strcmp                             IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "adl_action",622,"_adl_action"
	SEGMENT STRSECT
L__110:
	DB	"0"
	DB	0
L__112:
	DB	"1"
	DB	0
	SEGMENT CODE
;  623	
;  624	// get the number of bytes to emit from an immediate
;  625	uint8_t get_immediate_size(operand *op, uint8_t suffix) {
_get_immediate_size:
.DEFINE "_get_immediate_size"

.VALUE _get_immediate_size

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "get_immediate_size",625,"_get_immediate_size"

.LINE 625

.DEFINE "op"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "suffix"

.CLASS 65

.VALUE 9

.TYPE 12

.ENDEF

.DEFINE "num"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;  626	    uint8_t num;
;  627	    switch(suffix) {
.LINE 627

	LD	A,(IX+%9)
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__115:
	DW	5
	DB	0
	DW24	L_295	

	DB	1
	DW24	L_291	

	DB	2
	DW24	L_292	

	DB	4
	DW24	L_293	

	DB	8
	DW24	L_294	

	DW24	L_299	

;  628	        case S_SIS:
L_291:
.LINE 628

;  629	        case S_LIS:
L_292:
.LINE 629

;  630	            num = 2;
.LINE 630

	LD	(IX+%FFFFFFFF),%2
;  631	            break;
.LINE 631

	JR	L_302
;  632	        case S_SIL:
L_293:
.LINE 632

;  633	        case S_LIL:
L_294:
.LINE 633

;  634	            num = 3;
.LINE 634

	LD	(IX+%FFFFFFFF),%3
;  635	            break;
.LINE 635

	JR	L_302
;  636	        case 0: // Use current ADL mode to determine 16/24 bit
L_295:
.LINE 636

;  637	            if(adlmode) num = 3;
.LINE 637

	LD	A,(_adlmode)
	OR	A,A
	JR	Z,L_297
	LD	(IX+%FFFFFFFF),%3
;  638	            else num = 2;
.LINE 638

	JR	L_302
L_297:
	LD	(IX+%FFFFFFFF),%2
;  639	            break;
.LINE 639

	JR	L_302
;  640	        default:
L_299:
.LINE 640

;  641	            error(message[ERROR_INVALIDMNEMONIC]);
.LINE 641

	LD	HL,_message+18
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  642	            return 0;
.LINE 642

	XOR	A,A
	JR	L_304
;  643	    }
L_302:
.LINE 643

;  644	    if((num == 2) && (op->immediate > 0xFFFF)) error(message[ERROR_MMN_TOOLARGE]);
.LINE 644

	LD	A,(IX+%FFFFFFFF)
	CP	A,%2
	JR	NZ,L_303
	LD	HL,65535
	LD	E,%0
	LD	IY,(IX+%6)
	LD	BC,(IY+%B)
	LD	A,(IY+%E)
	CALL	__lcmps
	JP	P,L_303
	LD	HL,_message+39
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_303:
;  645	    return num;
.LINE 645

	LD	A,(IX+%FFFFFFFF)
;  646	}
L_304:
.LINE 646

	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_immediate_size ***************************
;Name                         Addr/Register   Size   Type
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_adlmode                            IMPORT      1   variable
;num                                   IX-1      1   variable
;suffix                                IX+9      1   parameter
;op                                    IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "get_immediate_size",646,"_get_immediate_size"
;  647	// Emit a 16 or 24 bit immediate number, according to
;  648	// given suffix bit, or in lack of it, the current ADL mode
;  649	void emit_immediate(operand *op, uint8_t suffix) {
_emit_immediate:
.DEFINE "_emit_immediate"

.VALUE _emit_immediate

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emit_immediate",649,"_emit_immediate"

.LINE 649

.DEFINE "op"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "suffix"

.CLASS 65

.VALUE 9

.TYPE 12

.ENDEF

.DEFINE "num"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;  650	    uint8_t num;
;  651	
;  652	    num = get_immediate_size(op, suffix);
.LINE 652

	LD	C,(IX+%9)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_get_immediate_size
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  653	    emit_8bit(op->immediate & 0xFF);
.LINE 653

	LD	IY,(IX+%6)
	LD	B,(IY+%B)
	LD	A,B
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  654	    emit_8bit((op->immediate >> 8) & 0xFF);
.LINE 654

	LD	IY,(IX+%6)
	LD	BC,(IY+%B)
	LD	A,(IY+%E)
	LD	L,%8
	CALL	__lshrs
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  655	    if(num == 3) emit_8bit((op->immediate >> 16) & 0xFF);
.LINE 655

	LD	A,(IX+%FFFFFFFF)
	CP	A,%3
	JR	NZ,L_306
	LD	IY,(IX+%6)
	LD	BC,(IY+%B)
	LD	A,(IY+%E)
	LD	L,%10
	CALL	__lshrs
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  656	}
L_306:
.LINE 656

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emit_immediate ***************************
;Name                         Addr/Register   Size   Type
;_emit_8bit                          IMPORT  -----   function
;num                                   IX-1      1   variable
;suffix                                IX+9      1   parameter
;op                                    IX+6      3   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emit_immediate",656,"_emit_immediate"
;  657	
;  658	void emit_adlsuffix_code(uint8_t suffix) {
_emit_adlsuffix_code:
.DEFINE "_emit_adlsuffix_code"

.VALUE _emit_adlsuffix_code

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emit_adlsuffix_code",658,"_emit_adlsuffix_code"

.LINE 658

.DEFINE "suffix"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "code"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;  659	    uint8_t code;
;  660	    switch(suffix) {
.LINE 660

	LD	A,(IX+%6)
	UEXT	HL
	LD	L,A
	CALL	__case8D
	JP	(HL)
L__122:
	DW	4
	DB	1
	DW24	L_307	

	DB	2
	DW24	L_308	

	DB	4
	DW24	L_309	

	DB	8
	DW24	L_310	

	DW24	L_311	

;  661	        case S_SIS:
L_307:
.LINE 661

;  662	            code = CODE_SIS;
.LINE 662

	LD	(IX+%FFFFFFFF),%40
;  663	            break;
.LINE 663

	JR	L_312
;  664	        case S_LIS:
L_308:
.LINE 664

;  665	            code = CODE_LIS;
.LINE 665

	LD	(IX+%FFFFFFFF),%49
;  666	            break;
.LINE 666

	JR	L_312
;  667	        case S_SIL:
L_309:
.LINE 667

;  668	            code = CODE_SIL;
.LINE 668

	LD	(IX+%FFFFFFFF),%52
;  669	            break;
.LINE 669

	JR	L_312
;  670	        case S_LIL:
L_310:
.LINE 670

;  671	            code = CODE_LIL;
.LINE 671

	LD	(IX+%FFFFFFFF),%5B
;  672	            break;
.LINE 672

	JR	L_312
;  673	        default:
L_311:
.LINE 673

;  674	            error(message[ERROR_INVALIDSUFFIX]);
.LINE 674

	LD	HL,_message+36
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  675	            return;
.LINE 675

	JR	L_313
;  676	    }
L_312:
.LINE 676

;  677	    emit_8bit(code);
.LINE 677

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  678	}
L_313:
.LINE 678

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emit_adlsuffix_code ***************************
;Name                         Addr/Register   Size   Type
;_emit_8bit                          IMPORT  -----   function
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;code                                  IX-1      1   variable
;suffix                                IX+6      1   parameter


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emit_adlsuffix_code",678,"_emit_adlsuffix_code"
;  679	
;  680	uint8_t get_ddfd_prefix(cpuregister reg) {
_get_ddfd_prefix:
.DEFINE "_get_ddfd_prefix"

.VALUE _get_ddfd_prefix

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "get_ddfd_prefix",680,"_get_ddfd_prefix"

.LINE 680

.DEFINE "reg"

.CLASS 65

.VALUE 6

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  681	    switch(reg) {
.LINE 681

	LD	HL,(IX+%6)
	CALL	__seqcaseD
	JP	(HL)
L__124:
	DW	6
	DW	13
	DB	0
	DW24	L_314	

	DW24	L_317	

	DW24	L_315	

	DW24	L_316	

	DW24	L_318	

	DW24	L_319	

	DW24	L_321	

;  682	        case R_IX:
L_314:
.LINE 682

;  683	        case R_IXH:
L_315:
.LINE 683

;  684	        case R_IXL:
L_316:
.LINE 684

;  685	            return 0xDD;
.LINE 685

	LD	A,%DD
	JR	L_322
;  686	        case R_IY:
L_317:
.LINE 686

;  687	        case R_IYH:
L_318:
.LINE 687

;  688	        case R_IYL:
L_319:
.LINE 688

;  689	            return 0xFD;
.LINE 689

	LD	A,%FD
	JR	L_322
;  690	        default:
;  691	            break;
;  692	    }
L_321:
.LINE 692

;  693	    return 0;    
.LINE 693

	XOR	A,A
;  694	}
L_322:
.LINE 694

	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_ddfd_prefix ***************************
;Name                         Addr/Register   Size   Type
;reg                                   IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "get_ddfd_prefix",694,"_get_ddfd_prefix"
;  695	
;  696	void prefix_ddfd_suffix(operandlist *op) {
_prefix_ddfd_suffix:
.DEFINE "_prefix_ddfd_suffix"

.VALUE _prefix_ddfd_suffix

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "prefix_ddfd_suffix",696,"_prefix_ddfd_suffix"

.LINE 696

.DEFINE "op"

.CLASS 65

.VALUE 6

.TAG "NONAME5"

.TYPE 40

.ENDEF

.DEFINE "prefix2"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "prefix1"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
	DEC	SP
;  697	    uint8_t prefix1, prefix2;
;  698	
;  699	    if(op->ddfdpermitted) {
.LINE 699

	LD	IY,(IX+%6)
	LD	A,(IY+%6)
	OR	A,A
	JR	Z,L_331
;  700	        prefix1 = get_ddfd_prefix(operand1.reg);
.LINE 700

	LD	BC,(_operand1)
	PUSH	BC
	CALL	_get_ddfd_prefix
	POP	BC
	LD	(IX+%FFFFFFFE),A
;  701	        prefix2 = get_ddfd_prefix(operand2.reg);
.LINE 701

	LD	BC,(_operand2)
	PUSH	BC
	CALL	_get_ddfd_prefix
	POP	BC
	LD	(IX+%FFFFFFFF),A
;  702	
;  703	
;  704	        // prefix in either of these two cases
;  705	        if(prefix1) {
.LINE 705

	LD	A,(IX+%FFFFFFFE)
	OR	A,A
	JR	Z,L_329
;  706	            if(prefix2) {
.LINE 706

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	Z,L_326
;  707	                // both prefixes set
;  708	                if(operand1.indirect) {
.LINE 708

	LD	A,(_operand1+4)
	OR	A,A
	JR	Z,L_324
;  709	                    output.prefix1 = prefix1;
.LINE 709

	LD	A,(IX+%FFFFFFFE)
	LD	(_output+1),A
;  710	                }
;  711	                else {
.LINE 711

	JR	L_331
L_324:
;  712	                    output.prefix1 = prefix2;
.LINE 712

	LD	A,(IX+%FFFFFFFF)
	LD	(_output+1),A
;  713	                }
;  714	            }
;  715	            else {
.LINE 715

	JR	L_331
L_326:
;  716	                output.prefix1 = prefix1;
.LINE 716

	LD	A,(IX+%FFFFFFFE)
	LD	(_output+1),A
;  717	            }
;  718	        }
;  719	        else {
.LINE 719

	JR	L_331
L_329:
;  720	            if(prefix2) {
.LINE 720

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	Z,L_331
;  721	                output.prefix1 = prefix2;
.LINE 721

	LD	A,(IX+%FFFFFFFF)
	LD	(_output+1),A
;  722	            }
;  723	        }
;  724	    }
;  725	}
L_331:
.LINE 725

	LD	SP,IX
	POP	IX
	RET	


;**************************** _prefix_ddfd_suffix ***************************
;Name                         Addr/Register   Size   Type
;_output                             IMPORT      4   variable
;_operand2                           IMPORT     16   variable
;_operand1                           IMPORT     16   variable
;prefix1                               IX-2      1   variable
;prefix2                               IX-1      1   variable
;op                                    IX+6      3   parameter


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "prefix_ddfd_suffix",725,"_prefix_ddfd_suffix"
;  726	
;  727	void transform_instruction(operand *op, permittype type) {
_transform_instruction:
.DEFINE "_transform_instruction"

.VALUE _transform_instruction

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "transform_instruction",727,"_transform_instruction"

.LINE 727

.DEFINE "op"

.CLASS 65

.VALUE 6

.TAG "NONAME3"

.TYPE 40

.ENDEF

.DEFINE "type"

.CLASS 65

.VALUE 9

.TYPE 4

.ENDEF

.DEFINE "y"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "rel"

.CLASS 65

.VALUE -5

.TYPE 5

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
;  728	    uint8_t y;
;  729	    int32_t rel;
;  730	
;  731	    switch(type) {
.LINE 731

	LD	HL,(IX+%9)
	CALL	__case8D
	JP	(HL)
L__132:
	DW	11
	DB	0
	DW24	L_366	

	DB	2
	DW24	L_341	

	DB	3
	DW24	L_340	

	DB	4
	DW24	L_345	

	DB	7
	DW24	L_346	

	DB	8
	DW24	L_332	

	DB	9
	DW24	L_336	

	DB	10
	DW24	L_349	

	DB	11
	DW24	L_347	

	DB	12
	DW24	L_348	

	DB	13
	DW24	L_355	

	DW24	L_365	

;  732	        case TRANSFORM_IR0:
L_332:
.LINE 732

;  733	            if((op->reg == R_IXL) || (op->reg == R_IYL)) output.opcode |= 0x01;
.LINE 733

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF8),BC
	LD	BC,16
	LD	HL,(IX+%FFFFFFF8)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_334
	LD	BC,18
	LD	HL,(IX+%FFFFFFF8)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_366
L_334:
	LD	A,(_output+3)
	SET	%0,A
	LD	(_output+3),A
;  734	            break;
.LINE 734

	JR	L_366
;  735	        case TRANSFORM_IR3:
L_336:
.LINE 735

;  736	            if((op->reg == R_IXL) || (op->reg == R_IYL)) output.opcode |= 0x08;
.LINE 736

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF5),BC
	LD	BC,16
	LD	HL,(IX+%FFFFFFF5)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_338
	LD	BC,18
	LD	HL,(IX+%FFFFFFF5)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_366
L_338:
	LD	A,(_output+3)
	SET	%3,A
	LD	(_output+3),A
;  737	            break;
.LINE 737

	JR	L_366
;  738	        case TRANSFORM_Z:
L_340:
.LINE 738

;  739	            output.opcode |= op->reg_index;
.LINE 739

	LD	A,(_output+3)
	LD	IY,(IX+%6)
	OR	A,(IY+%3)
	LD	(_output+3),A
;  740	            break;
.LINE 740

	JR	L_366
;  741	        case TRANSFORM_Y:
L_341:
.LINE 741

;  742	            if(op->immediate_provided) output.opcode |= (op->immediate << 3);
.LINE 742

	LD	IY,(IX+%6)
	LD	A,(IY+%A)
	OR	A,A
	JR	Z,L_343
	LD	IY,(IX+%6)
	LD	A,(IY+%B)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	BC,(_output+3)
	OR	A,C
	LD	(_output+3),A
;  743	            else output.opcode |= (op->reg_index << 3);
.LINE 743

	JR	L_366
L_343:
	LD	IY,(IX+%6)
	LD	A,(IY+%3)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,(_output+3)
	OR	A,B
	LD	(_output+3),A
;  744	            break;
.LINE 744

	JR	L_366
;  745	        case TRANSFORM_P:
L_345:
.LINE 745

;  746	            output.opcode |= (op->reg_index << 4);
.LINE 746

	LD	IY,(IX+%6)
	LD	A,(IY+%3)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,(_output+3)
	OR	A,B
	LD	(_output+3),A
;  747	            break;
.LINE 747

	JR	L_366
;  748	        case TRANSFORM_CC:
L_346:
.LINE 748

;  749	            output.opcode |= (op->cc_index << 3);
.LINE 749

	LD	IY,(IX+%6)
	LD	A,(IY+%6)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,(_output+3)
	OR	A,B
	LD	(_output+3),A
;  750	            break;
.LINE 750

	JR	L_366
;  751	        case TRANSFORM_N:
L_347:
.LINE 751

;  752	            output.opcode |= op->immediate;
.LINE 752

	LD	IY,(IX+%6)
	LD	B,(IY+%B)
	LD	A,(_output+3)
	OR	A,B
	LD	(_output+3),A
;  753	            op->immediate_provided = false; // no separate output for this transform
.LINE 753

	LD	(IY+%A),%0
;  754	            break;
.LINE 754

	JR	L_366
;  755	        case TRANSFORM_BIT:
L_348:
.LINE 755

;  756	            output.opcode |= (op->immediate << 3);
.LINE 756

	LD	IY,(IX+%6)
	LD	A,(IY+%B)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	BC,(_output+3)
	OR	A,C
	LD	(_output+3),A
;  757	            op->immediate_provided = false;
.LINE 757

	LD	(IY+%A),%0
;  758	            break;
.LINE 758

	JR	L_366
;  759	        case TRANSFORM_SELECT:
L_349:
.LINE 759

;  760	            switch(op->immediate) {
.LINE 760

	LD	IY,(IX+%6)
	LD	HL,(IY+%B)
	CALL	__seqcaseD
	JP	(HL)
L__138:
	DW	3
	DW	0
	DB	0
	DW24	L_350	

	DW24	L_351	

	DW24	L_352	

	DW24	L_353	

;  761	                case 0:
L_350:
.LINE 761

;  762	                    y = 0;
.LINE 762

	LD	(IX+%FFFFFFFF),%0
;  763	                    break;
.LINE 763

	JR	L_354
;  764	                case 1:
L_351:
.LINE 764

;  765	                    y = 2;
.LINE 765

	LD	(IX+%FFFFFFFF),%2
;  766	                    break;
.LINE 766

	JR	L_354
;  767	                case 2:
L_352:
.LINE 767

;  768	                    y = 3;
.LINE 768

	LD	(IX+%FFFFFFFF),%3
;  769	                    break;
.LINE 769

	JR	L_354
;  770	                default:
L_353:
.LINE 770

;  771	                    y = 0;
.LINE 771

	LD	(IX+%FFFFFFFF),%0
;  772	            }
L_354:
.LINE 772

;  773	            output.opcode |= (y << 3); // shift 3 lower bits 3 to the left
.LINE 773

	LD	A,(IX+%FFFFFFFF)
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	B,A
	LD	A,(_output+3)
	OR	A,B
	LD	(_output+3),A
;  774	            op->immediate_provided = false; // no separate output for this transform
.LINE 774

	LD	IY,(IX+%6)
	LD	(IY+%A),%0
;  775	            break;
.LINE 775

	JR	L_366
;  776	        case TRANSFORM_REL:
L_355:
.LINE 776

;  777	            if(pass == 2) {
.LINE 777

	LD	BC,2
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_366
;  778	                // label still potentially unknown in pass 1, so output the existing '0' in pass 1
;  779	                if(op->wasLabel) rel = op->immediate - address - 2;
.LINE 779

	LD	IY,(IX+%6)
	LD	A,(IY+%F)
	OR	A,A
	JR	Z,L_357
	LD	IY,(IX+%6)
	LD	HL,(IY+%B)
	LD	E,(IY+%E)
	LD	BC,(_address)
	LD	A,(_address+3)
	CALL	__lsub
	LD	BC,16777214
	LD	A,%FF
	CALL	__ladd
	LD	(IX+%FFFFFFFB),HL
	LD	(IX+%FFFFFFFE),E
;  780	                else rel = op->immediate; // user asked for specific offset
.LINE 780

	JR	L_360
L_357:
	LD	IY,(IX+%6)
	LD	BC,(IY+%B)
	LD	A,(IY+%E)
	LD	(IX+%FFFFFFFB),BC
	LD	(IX+%FFFFFFFE),A
L_360:
;  781	                if((rel > 127) || (rel < -128)) error(message[ERROR_RELATIVEJUMPTOOLARGE]);
.LINE 781

	LD	HL,127
	LD	E,%0
	LD	BC,(IX+%FFFFFFFB)
	LD	A,(IX+%FFFFFFFE)
	CALL	__lcmps
	JP	M,L_359
	LD	HL,(IX+%FFFFFFFB)
	LD	E,(IX+%FFFFFFFE)
	LD	BC,16777088
	LD	A,%FF
	CALL	__lcmps
	CALL	__setflag
	JP	P,L_361
L_359:
	LD	HL,_message+66
	LD	BC,(HL)
	PUSH	BC
	LD	(IX+%FFFFFFF4),A
	CALL	_error
	LD	A,(IX+%FFFFFFF4)
	POP	BC
L_361:
;  782	                op->immediate = ((int8_t)(rel & 0xFF));
.LINE 782

	UEXT	HL
	LD	L,(IX+%FFFFFFFB)
	LD	BC,HL
	LD	A,C
	SEXT	HL
	LD	L,C
	LD	IY,(IX+%6)
	LD	(IY+%B),HL
	LD	(IY+%E),H
;  783	                op->immediate_provided = true;
.LINE 783

	LD	(IY+%A),%1
;  784	            }
.LINE 784

;  785	            break;
.LINE 785

	JR	L_366
;  786	        case TRANSFORM_NONE:
;  787	            break;
;  788	        default:
L_365:
.LINE 788

;  789	            error(message[ERROR_TRANSFORMATION]);
.LINE 789

	LD	HL,_message+27
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  790	            break;
;  791	    }
L_366:
.LINE 791

;  792	    return;
;  793	}
.LINE 793

	LD	SP,IX
	POP	IX
	RET	


;**************************** _transform_instruction ***************************
;Name                         Addr/Register   Size   Type
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_address                            IMPORT      4   variable
;_pass                               IMPORT      3   variable
;_output                             IMPORT      4   variable
;G_16                                 IX-11      3   variable
;G_15                                  IX-8      3   variable
;rel                                   IX-5      4   variable
;y                                     IX-1      1   variable
;type                                  IX+9      3   parameter
;op                                    IX+6      3   parameter


; Stack Frame Size: 24 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "transform_instruction",793,"_transform_instruction"
;  794	
;  795	void emit_instruction(operandlist *list) {
_emit_instruction:
.DEFINE "_emit_instruction"

.VALUE _emit_instruction

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emit_instruction",795,"_emit_instruction"

.LINE 795

.DEFINE "list"

.CLASS 65

.VALUE 6

.TAG "NONAME5"

.TYPE 40

.ENDEF

.DEFINE "ddbeforeopcode"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEA
	LD	SP,HL
;  796	    bool ddbeforeopcode; // determine position of displacement byte in case of DDCBdd/DDFDdd
;  797	
;  798	    // Transform necessary prefix/opcode in output, according to given list and operands
;  799	    output.suffix = getADLsuffix();
.LINE 799

	CALL	_getADLsuffix
	LD	(_output),A
;  800	    output.prefix1 = 0;
.LINE 800

	XOR	A,A
	LD	(_output+1),A
;  801	    output.prefix2 = list->prefix;
.LINE 801

	LD	IY,(IX+%6)
	LD	A,(IY+%D)
	LD	(_output+2),A
;  802	    output.opcode = list->opcode;
.LINE 802

	LD	A,(IY+%E)
	LD	(_output+3),A
;  803	
;  804	    if(pass == 1) definelabel(address);
.LINE 804

	LD	BC,1
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_380
	LD	A,(_address+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_address)
	PUSH	BC
	CALL	_definelabel
	POP	BC
	POP	BC
L_380:
;  805	
;  806	    // issue any errors here
;  807	    if((list->transformA != TRANSFORM_REL) && (list->transformB != TRANSFORM_REL)) { // TRANSFORM_REL will mask to 0xFF
.LINE 807

	LD	BC,13
	LD	IY,(IX+%6)
	LD	HL,(IY+%7)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_383
	LD	IY,(IX+%6)
	LD	HL,(IY+%A)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_383
;  808	        if(((list->operandA == OPTYPE_N) || (list->operandA == OPTYPE_INDIRECT_N)) && ((operand1.immediate > 0xFF) || (operand1.immediate < -128))) error(message[WARNING_N_8BITRANGE]);
.LINE 808

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF9),BC
	LD	BC,8
	LD	HL,(IX+%FFFFFFF9)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_372
	LD	BC,25
	LD	HL,(IX+%FFFFFFF9)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_378
L_372:
	LD	HL,255
	LD	E,%0
	LD	BC,(_operand1+11)
	LD	A,(_operand1+14)
	CALL	__lcmps
	CALL	__setflag
	JP	M,L_373
	LD	HL,(_operand1+11)
	LD	A,(_operand1+14)
	LD	E,A
	LD	BC,16777088
	LD	A,%FF
	CALL	__lcmps
	CALL	__setflag
	JP	P,L_378
L_373:
	LD	HL,_message+33
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_378:
;  809	        if(((list->operandB == OPTYPE_N) || (list->operandB == OPTYPE_INDIRECT_N)) && ((operand2.immediate > 0xFF) || (operand2.immediate < -128))) error(message[WARNING_N_8BITRANGE]);
.LINE 809

	LD	IY,(IX+%6)
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFF6),BC
	LD	BC,8
	LD	HL,(IX+%FFFFFFF6)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_376
	LD	BC,25
	LD	HL,(IX+%FFFFFFF6)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_383
L_376:
	LD	HL,255
	LD	E,%0
	LD	BC,(_operand2+11)
	LD	A,(_operand2+14)
	CALL	__lcmps
	CALL	__setflag
	JP	M,L_377
	LD	HL,(_operand2+11)
	LD	A,(_operand2+14)
	LD	E,A
	LD	BC,16777088
	LD	A,%FF
	CALL	__lcmps
	CALL	__setflag
	JP	P,L_383
L_377:
	LD	HL,_message+33
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  810	    }
L_383:
.LINE 810

;  811	    if((output.suffix) && ((list->adl & output.suffix) == 0)) error(message[ERROR_ILLEGAL_SUFFIXMODE]);
.LINE 811

	LD	A,(_output)
	OR	A,A
	JR	Z,L_387
	LD	A,(_output)
	LD	IY,(IX+%6)
	AND	A,(IY+%F)
	JR	NZ,L_387
	LD	HL,_message+42
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_387:
;  812	    if((operand2.displacement_provided) && ((operand2.displacement < -128) || (operand2.displacement > 127))) error(message[ERROR_DISPLACEMENT_RANGE]);
.LINE 812

	LD	A,(_operand2+9)
	OR	A,A
	JR	Z,L_390
	LD.LIS	BC,-128
	LD	HL,(_operand2+7)
	OR	A,A
	SBC.SIS	HL,BC
	JP	M,L_386
	LD	BC,(_operand2+7)
	LD.LIS	HL,127
	OR	A,A
	SBC.SIS	HL,BC
	CALL	__setflag
	JP	P,L_390
L_386:
	LD	HL,_message+45
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_390:
;  813	
;  814	    // Specific checks
;  815	    if((list->operandA == OPTYPE_BIT) && (operand1.immediate > 7)) error(message[ERROR_INVALIDBITNUMBER]);
.LINE 815

	LD	BC,21
	LD	IY,(IX+%6)
	LD	HL,(IY+%0)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_393
	LD	HL,7
	LD	E,%0
	LD	BC,(_operand1+11)
	LD	A,(_operand1+14)
	CALL	__lcmps
	CALL	__setflag
	JP	P,L_393
	LD	HL,_message+69
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_393:
;  816	    if((list->operandA == OPTYPE_NSELECT) && (operand1.immediate > 2)) error(message[ERROR_ILLEGALINTERRUPTMODE]);
.LINE 816

	LD	BC,24
	LD	IY,(IX+%6)
	LD	HL,(IY+%0)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_396
	LD	HL,2
	LD	E,%0
	LD	BC,(_operand1+11)
	LD	A,(_operand1+14)
	CALL	__lcmps
	CALL	__setflag
	JP	P,L_396
	LD	HL,_message+72
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_396:
;  817	    if((list->transformA == TRANSFORM_N) && (operand1.immediate & 0x47)) error(message[ERROR_ILLEGALRESTARTADDRESS]);
.LINE 817

	LD	BC,11
	LD	IY,(IX+%6)
	LD	HL,(IY+%7)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_397
	LD	A,(_operand1+11)
	AND	A,%47
	UEXT	HL
	LD	L,A
	LD	E,H
	CALL	__lcmpzero
	JR	Z,L_397
	LD	HL,_message+75
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_397:
;  818	
;  819	    // prepare extra DD/FD suffix if needed
;  820	    prefix_ddfd_suffix(list);
.LINE 820

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_prefix_ddfd_suffix
	POP	BC
;  821	    // Transform the opcode and potential immediate values, according to the current ruleset
;  822	    transform_instruction(&operand1, list->transformA);
.LINE 822

	LD	IY,(IX+%6)
	LD	BC,(IY+%7)
	PUSH	BC
	LD	BC,_operand1
	PUSH	BC
	CALL	_transform_instruction
	POP	BC
	POP	BC
;  823	    transform_instruction(&operand2, list->transformB);
.LINE 823

	LD	IY,(IX+%6)
	LD	BC,(IY+%A)
	PUSH	BC
	LD	BC,_operand2
	PUSH	BC
	CALL	_transform_instruction
	POP	BC
	POP	BC
;  824	    // determine position of dd
;  825	    ddbeforeopcode = (((output.prefix1 == 0xDD) || (output.prefix1 == 0xFD)) && (output.prefix2 == 0xCB) &&
.LINE 825

	LD	A,(_output+1)
	CP	A,%DD
	JR	Z,L_399
	LD	A,(_output+1)
	CP	A,%FD
	JR	NZ,L_403
L_399:
	LD	A,(_output+2)
	CP	A,%CB
	JR	NZ,L_403
;  826	                ((operand1.displacement_provided) || (operand2.displacement_provided)));
.LINE 826

	LD	A,(_operand1+9)
	OR	A,A
	JR	NZ,L_402
	LD	A,(_operand2+9)
	OR	A,A
	JR	Z,L_403
L_402:
	LD	BC,1
	LD	(IX+%FFFFFFFC),BC
	JR	L_404
L_403:
	LD	BC,0
	LD	(IX+%FFFFFFFC),BC
L_404:
	LD	A,(IX+%FFFFFFFC)
	LD	(IX+%FFFFFFFF),A
;  827	    
;  828	    // output adl suffix and any prefixes
;  829	    if(output.suffix > 0) emit_adlsuffix_code(output.suffix);
.LINE 829

	XOR	A,A
	LD	HL,_output
	CP	A,(HL)
	JR	NC,L_408
	LD	A,(_output)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_adlsuffix_code
	POP	BC
L_408:
;  830	    if(output.prefix1) emit_8bit(output.prefix1);
.LINE 830

	LD	A,(_output+1)
	OR	A,A
	JR	Z,L_410
	LD	A,(_output+1)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
L_410:
;  831	    if(output.prefix2) emit_8bit(output.prefix2);
.LINE 831

	LD	A,(_output+2)
	OR	A,A
	JR	Z,L_412
	LD	A,(_output+2)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
L_412:
;  832	
;  833	    // opcode in normal position
;  834	    if(!ddbeforeopcode) emit_8bit(output.opcode);
.LINE 834

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	NZ,L_414
	LD	A,(_output+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
L_414:
;  835	    
;  836	    // output displacement
;  837	    if(operand1.displacement_provided) emit_8bit(operand1.displacement & 0xFF);
.LINE 837

	LD	A,(_operand1+9)
	OR	A,A
	JR	Z,L_416
	LD	A,(_operand1+7)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
L_416:
;  838	    if(operand2.displacement_provided) emit_8bit(operand2.displacement & 0xFF);
.LINE 838

	LD	A,(_operand2+9)
	OR	A,A
	JR	Z,L_420
	LD	A,(_operand2+7)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
L_420:
;  839	    // output n
;  840	    if((operand1.immediate_provided) && ((list->operandA == OPTYPE_N) || (list->operandA == OPTYPE_INDIRECT_N))) emit_8bit(operand1.immediate & 0xFF);
.LINE 840

	LD	A,(_operand1+10)
	OR	A,A
	JR	Z,L_424
	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF3),BC
	LD	BC,8
	LD	HL,(IX+%FFFFFFF3)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_419
	LD	BC,25
	LD	HL,(IX+%FFFFFFF3)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_424
L_419:
	LD	A,(_operand1+11)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
L_424:
;  841	    if((operand2.immediate_provided) && ((list->operandB == OPTYPE_N) || (list->operandB == OPTYPE_INDIRECT_N))) emit_8bit(operand2.immediate & 0xFF);
.LINE 841

	LD	A,(_operand2+10)
	OR	A,A
	JR	Z,L_426
	LD	IY,(IX+%6)
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFF0),BC
	LD	BC,8
	LD	HL,(IX+%FFFFFFF0)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_423
	LD	BC,25
	LD	HL,(IX+%FFFFFFF0)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_426
L_423:
	LD	A,(_operand2+11)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
L_426:
;  842	
;  843	
;  844	    // opcode in DDCBdd/DFCBdd position
;  845	    if(ddbeforeopcode) emit_8bit(output.opcode);
.LINE 845

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	Z,L_429
	LD	A,(_output+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
L_429:
;  846	
;  847	    //output remaining immediate bytes
;  848	    if((list->operandA == OPTYPE_MMN) || (list->operandA == OPTYPE_INDIRECT_MMN)) emit_immediate(&operand1, output.suffix);
.LINE 848

	LD	IY,(IX+%6)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFED),BC
	LD	BC,6
	LD	HL,(IX+%FFFFFFED)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_428
	LD	BC,7
	LD	HL,(IX+%FFFFFFED)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_432
L_428:
	LD	A,(_output)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,_operand1
	PUSH	BC
	CALL	_emit_immediate
	POP	BC
	POP	BC
L_432:
;  849	    if((list->operandB == OPTYPE_MMN) || (list->operandB == OPTYPE_INDIRECT_MMN)) emit_immediate(&operand2, output.suffix);
.LINE 849

	LD	IY,(IX+%6)
	LD	BC,(IY+%3)
	LD	(IX+%FFFFFFEA),BC
	LD	BC,6
	LD	HL,(IX+%FFFFFFEA)
	OR	A,A
	SBC	HL,BC
	JR	Z,L_431
	LD	BC,7
	LD	HL,(IX+%FFFFFFEA)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_433
L_431:
	LD	A,(_output)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,_operand2
	PUSH	BC
	CALL	_emit_immediate
	POP	BC
	POP	BC
;  850	}
L_433:
.LINE 850

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emit_instruction ***************************
;Name                         Addr/Register   Size   Type
;_emit_8bit                          IMPORT  -----   function
;_operand2                           IMPORT     16   variable
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_operand1                           IMPORT     16   variable
;_address                            IMPORT      4   variable
;_pass                               IMPORT      3   variable
;_output                             IMPORT      4   variable
;G_22                                 IX-22      3   variable
;G_21                                 IX-19      3   variable
;G_20                                 IX-16      3   variable
;G_19                                 IX-13      3   variable
;G_18                                 IX-10      3   variable
;G_17                                  IX-7      3   variable
;temp405                               IX-4      3   variable
;ddbeforeopcode                        IX-1      1   variable
;list                                  IX+6      3   parameter


; Stack Frame Size: 31 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emit_instruction",850,"_emit_instruction"
;  851	
;  852	void emit_8bit(uint8_t value) {
_emit_8bit:
.DEFINE "_emit_8bit"

.VALUE _emit_8bit

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emit_8bit",852,"_emit_8bit"

.LINE 852

.DEFINE "value"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  853	    if(pass == 2) {
.LINE 853

	LD	BC,2
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_436
;  854	        listEmit8bit(value);
.LINE 854

	LD	C,(IX+%6)
	LD	B,%0
	PUSH	BC
	CALL	_listEmit8bit
	POP	BC
;  855	        agon_fwrite(&value, sizeof(char), 1, FILE_OUTPUT);
.LINE 855

	LD	BC,2
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PUSH	BC
	PEA	IX+%6
	CALL	_agon_fwrite
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  856	    }
L_436:
.LINE 856

;  857	    address++;
.LINE 857

	LD	HL,(_address)
	LD	A,(_address+3)
	LD	E,A
	LD	A,%1
	CALL	__ladd_b
	LD	(_address),HL
	LD	A,E
	LD	(_address+3),A
;  858	    totalsize++;
.LINE 858

	LD	HL,(_totalsize)
	LD	A,(_totalsize+3)
	LD	E,A
	LD	A,%1
	CALL	__ladd_b
	LD	(_totalsize),HL
	LD	A,E
	LD	(_totalsize+3),A
;  859	}
.LINE 859

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emit_8bit ***************************
;Name                         Addr/Register   Size   Type
;_totalsize                          IMPORT      4   variable
;_address                            IMPORT      4   variable
;_agon_fwrite                        IMPORT  -----   function
;_listEmit8bit                       IMPORT  -----   function
;_pass                               IMPORT      3   variable
;value                                 IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emit_8bit",859,"_emit_8bit"
;  860	
;  861	void emit_16bit(uint16_t value) {
_emit_16bit:
.DEFINE "_emit_16bit"

.VALUE _emit_16bit

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emit_16bit",861,"_emit_16bit"

.LINE 861

.DEFINE "value"

.CLASS 65

.VALUE 6

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  862	    emit_8bit(value&0xFF);
.LINE 862

	LD	A,(IX+%6)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  863	    emit_8bit((value>>8)&0xFF);
.LINE 863

	LD	BC,(IX+%6)
	CALL	__stoiu
	LD	A,%8
	CALL	__ishrs_b
	LD	A,L
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  864	}
.LINE 864

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emit_16bit ***************************
;Name                         Addr/Register   Size   Type
;_emit_8bit                          IMPORT  -----   function
;value                                 IX+6      2   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emit_16bit",864,"_emit_16bit"
;  865	
;  866	void emit_24bit(uint32_t value) {
_emit_24bit:
.DEFINE "_emit_24bit"

.VALUE _emit_24bit

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emit_24bit",866,"_emit_24bit"

.LINE 866

.DEFINE "value"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  867	    emit_8bit(value&0xFF);
.LINE 867

	LD	A,(IX+%6)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  868	    emit_8bit((value>>8)&0xFF);
.LINE 868

	LD	BC,(IX+%6)
	LD	A,(IX+%9)
	LD	L,%8
	CALL	__lshru
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  869	    emit_8bit((value>>16)&0xFF);
.LINE 869

	LD	BC,(IX+%6)
	LD	A,(IX+%9)
	LD	L,%10
	CALL	__lshru
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  870	}
.LINE 870

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emit_24bit ***************************
;Name                         Addr/Register   Size   Type
;_emit_8bit                          IMPORT  -----   function
;value                                 IX+6      4   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emit_24bit",870,"_emit_24bit"
;  871	
;  872	void emit_32bit(uint32_t value) {
_emit_32bit:
.DEFINE "_emit_32bit"

.VALUE _emit_32bit

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emit_32bit",872,"_emit_32bit"

.LINE 872

.DEFINE "value"

.CLASS 65

.VALUE 6

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  873	    emit_8bit(value&0xFF);
.LINE 873

	LD	A,(IX+%6)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  874	    emit_8bit((value>>8)&0xFF);
.LINE 874

	LD	BC,(IX+%6)
	LD	A,(IX+%9)
	LD	L,%8
	CALL	__lshru
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  875	    emit_8bit((value>>16)&0xFF);
.LINE 875

	LD	BC,(IX+%6)
	LD	A,(IX+%9)
	LD	L,%10
	CALL	__lshru
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  876	    emit_8bit((value>>24)&0xFF);
.LINE 876

	LD	A,(IX+%9)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  877	}
.LINE 877

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emit_32bit ***************************
;Name                         Addr/Register   Size   Type
;_emit_8bit                          IMPORT  -----   function
;value                                 IX+6      4   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emit_32bit",877,"_emit_32bit"
;  878	
;  879	// return the value of a previously escaped character with backslash
;  880	uint8_t get_escaped_char(char n) {
_get_escaped_char:
.DEFINE "_get_escaped_char"

.VALUE _get_escaped_char

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "get_escaped_char",880,"_get_escaped_char"

.LINE 880

.DEFINE "n"

.CLASS 65

.VALUE 6

.TYPE 2

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  881	    switch(n) {
.LINE 881

	LD	A,(IX+%6)
	SEXT	HL
	LD	L,(IX+%6)
	CALL	__case8D
	JP	(HL)
L__194:
	DW	7
	DB	34
	DW24	L_447	

	DB	39
	DW24	L_448	

	DB	98
	DW24	L_445	

	DB	101
	DW24	L_446	

	DB	110
	DW24	L_442	

	DB	114
	DW24	L_443	

	DB	116
	DW24	L_444	

	DW24	L_449	

;  882	        case 'n':
L_442:
.LINE 882

;  883	            return(0x0a);
.LINE 883

	LD	A,%A
	JR	L_450
;  884	        case 'r':
L_443:
.LINE 884

;  885	            return(0x0d);
.LINE 885

	LD	A,%D
	JR	L_450
;  886	        case 't':
L_444:
.LINE 886

;  887	            return(0x09);
.LINE 887

	LD	A,%9
	JR	L_450
;  888	        case 'b':
L_445:
.LINE 888

;  889	            return(0x08);
.LINE 889

	LD	A,%8
	JR	L_450
;  890	        case 'e':
L_446:
.LINE 890

;  891	            return(0x1b);
.LINE 891

	LD	A,%1B
	JR	L_450
;  892	        case '\"':
L_447:
.LINE 892

;  893	            return('\"');
.LINE 893

	LD	A,%22
	JR	L_450
;  894	        case '\'':
L_448:
.LINE 894

;  895	            return('\'');
.LINE 895

	LD	A,%27
	JR	L_450
;  896	        default:
L_449:
.LINE 896

;  897	            return(n);
.LINE 897

	LD	A,(IX+%6)
;  898	    }
;  899	}
L_450:
.LINE 899

	LD	SP,IX
	POP	IX
	RET	


;**************************** _get_escaped_char ***************************
;Name                         Addr/Register   Size   Type
;n                                     IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "get_escaped_char",899,"_get_escaped_char"
;  900	
;  901	// emits a string surrounded by literal string quotes, as the token gets in from a file
;  902	void emit_quotedstring(char *str) {
_emit_quotedstring:
.DEFINE "_emit_quotedstring"

.VALUE _emit_quotedstring

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "emit_quotedstring",902,"_emit_quotedstring"

.LINE 902

.DEFINE "str"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "escaped"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	DEC	SP
;  903	    bool escaped = false;
.LINE 903

	LD	(IX+%FFFFFFFF),%0
;  904	
;  905	    if(*str == '\"') {
.LINE 905

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,34
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_478
;  906	        str++;
.LINE 906

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  907	        while(*str) {
.LINE 907

	JR	L_474
L_475:
;  908	            switch(*str) {
.LINE 908

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	CALL	__case8D
	JP	(HL)
L__197:
	DW	8
	DB	34
	DW24	L_465	

	DB	39
	DW24	L_461	

	DB	92
	DW24	L_452	

	DB	98
	DW24	L_459	

	DB	101
	DW24	L_460	

	DB	110
	DW24	L_456	

	DB	114
	DW24	L_457	

	DB	116
	DW24	L_458	

	DW24	L_471	

;  909	                case '\\':
L_452:
.LINE 909

;  910	                    if(escaped) {
.LINE 910

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	Z,L_454
;  911	                        emit_8bit('\\');
.LINE 911

	LD	BC,92
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  912	                        escaped = false;
.LINE 912

	LD	(IX+%FFFFFFFF),%0
;  913	                    }
;  914	                    else escaped = true;
.LINE 914

	JR	L_473
L_454:
	LD	(IX+%FFFFFFFF),%1
;  915	                    break;
.LINE 915

	JR	L_473
;  916	                case 'n':
L_456:
.LINE 916

;  917	                case 'r':
L_457:
.LINE 917

;  918	                case 't':
L_458:
.LINE 918

;  919	                case 'b':
L_459:
.LINE 919

;  920	                case 'e':
L_460:
.LINE 920

;  921	                case '\'':
L_461:
.LINE 921

;  922	                    if(escaped) emit_8bit(get_escaped_char(*str));
.LINE 922

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	Z,L_463
	LD	HL,(IX+%6)
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_get_escaped_char
	POP	BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  923	                    else emit_8bit(*str); // the normal character
.LINE 923

	JR	L_464
L_463:
	LD	HL,(IX+%6)
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
L_464:
;  924	                    escaped = false;
.LINE 924

	LD	(IX+%FFFFFFFF),%0
;  925	                    break;
.LINE 925

	JR	L_473
;  926	                case '\"':
L_465:
.LINE 926

;  927	                    if(escaped) {
.LINE 927

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	Z,L_469
;  928	                        emit_8bit('\"');
.LINE 928

	LD	BC,34
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  929	                        escaped = false;
.LINE 929

	LD	(IX+%FFFFFFFF),%0
;  930	                    }
;  931	                    else {
.LINE 931

	JR	L_473
L_469:
;  932	                        if(*(str+1) != 0) error(message[ERROR_STRINGFORMAT]);
.LINE 932

	LD	HL,(IX+%6)
	INC	HL
	LD	A,(HL)
	OR	A,A
	JR	Z,L_479
	LD	HL,_message+63
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  933	                        return; // end of quoted string
.LINE 933

	JR	L_479
;  934	                    }
;  935	                    break;
;  936	                default:
L_471:
.LINE 936

;  937	                    emit_8bit(*str);
.LINE 937

	LD	HL,(IX+%6)
	LD	C,(HL)
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
;  938	            }
L_473:
.LINE 938

;  939	            str++;
.LINE 939

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%6),BC
;  940	        }
L_474:
.LINE 940

	LD	HL,(IX+%6)
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_475
;  941	        // we missed an end-quote to this string, we shouldn't reach this
;  942	        error(message[ERROR_STRINGFORMAT]);
.LINE 942

	LD	HL,_message+63
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  943	    }
;  944	    else error(message[ERROR_STRINGFORMAT]);
.LINE 944

	JR	L_479
L_478:
	LD	HL,_message+63
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  945	}
L_479:
.LINE 945

	LD	SP,IX
	POP	IX
	RET	


;**************************** _emit_quotedstring ***************************
;Name                         Addr/Register   Size   Type
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_emit_8bit                          IMPORT  -----   function
;escaped                               IX-1      1   variable
;str                                   IX+6      3   parameter


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "emit_quotedstring",945,"_emit_quotedstring"
;  946	
;  947	void parse_asm_single_immediate(void) {
_parse_asm_single_immediate:
.DEFINE "_parse_asm_single_immediate"

.VALUE _parse_asm_single_immediate

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "parse_asm_single_immediate",947,"_parse_asm_single_immediate"

.LINE 947

.DEFINE "token"

.CLASS 65

.VALUE -261

.TAG "NONAME11"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-261
	ADD	HL,SP
	LD	SP,HL
;  948	    tokentype token;
;  949	
;  950	    if(currentline.next) {
.LINE 950

	LD	HL,(_currentline+3)
	CALL	__icmpzero
	JR	Z,L_484
;  951	        getLineToken(&token, currentline.next,0);
.LINE 951

	LD	BC,0
	PUSH	BC
	LD	BC,(_currentline+3)
	PUSH	BC
	LD	HL,IX
	LD	BC,-261
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
;  952	        if(notEmpty(token.start)) {
.LINE 952

	LD	HL,IX
	LD	BC,-261
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_notEmpty
	POP	BC
	OR	A,A
	JR	Z,L_482
;  953	            operand1.immediate = str2num(token.start,true);
.LINE 953

	LD	BC,1
	PUSH	BC
	LD	HL,IX
	LD	BC,-261
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_str2num
	POP	BC
	POP	BC
	LD	(_operand1+11),HL
	LD	A,E
	LD	(_operand1+14),A
;  954	            operand1.immediate_provided = true;
.LINE 954

	LD	A,%1
	LD	(_operand1+10),A
;  955	            if(token.terminator != 0) error(message[ERROR_TOOMANYARGUMENTS]);
.LINE 955

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	Z,L_485
	LD	HL,_message+87
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  956	        }
;  957	        else error(message[ERROR_MISSINGOPERAND]);
.LINE 957

	JR	L_485
L_482:
	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  958	    }
;  959	    else error(message[ERROR_MISSINGOPERAND]);
.LINE 959

	JR	L_485
L_484:
	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  960	}
L_485:
.LINE 960

	LD	SP,IX
	POP	IX
	RET	


;**************************** _parse_asm_single_immediate ***************************
;Name                         Addr/Register   Size   Type
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_operand1                           IMPORT     16   variable
;_str2num                            IMPORT  -----   function
;_notEmpty                           IMPORT  -----   function
;_getLineToken                       IMPORT  -----   function
;_currentline                        IMPORT    264   variable
;token                               IX-261    261   variable


; Stack Frame Size: 267 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "parse_asm_single_immediate",960,"_parse_asm_single_immediate"
;  961	
;  962	void parse_asm_keyval_pair(void) {
_parse_asm_keyval_pair:
.DEFINE "_parse_asm_keyval_pair"

.VALUE _parse_asm_keyval_pair

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "parse_asm_keyval_pair",962,"_parse_asm_keyval_pair"

.LINE 962

.DEFINE "token"

.CLASS 65

.VALUE -261

.TAG "NONAME11"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-261
	ADD	HL,SP
	LD	SP,HL
;  963	    tokentype token;
;  964	
;  965	    if(currentline.next) {
.LINE 965

	LD	HL,(_currentline+3)
	CALL	__icmpzero
	JR	Z,L_491
;  966	        getLineToken(&token, currentline.next, '=');
.LINE 966

	LD	BC,61
	PUSH	BC
	LD	BC,(_currentline+3)
	PUSH	BC
	LD	HL,IX
	LD	BC,-261
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
;  967	        strcpy(currentline.operand1, token.start);
.LINE 967

	LD	HL,IX
	LD	BC,-261
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	BC,_currentline+70
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  968	        if(token.terminator == '=') {
.LINE 968

	LD	A,(IX+%FFFFFFFF)
	CP	A,%3D
	JR	NZ,L_489
;  969	            getLineToken(&token, token.next, 0);
.LINE 969

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	LD	HL,IX
	LD	BC,-261
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
;  970	            if(notEmpty(token.start)) {
.LINE 970

	LD	HL,IX
	LD	BC,-261
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_notEmpty
	POP	BC
	OR	A,A
	JR	Z,L_487
;  971	                operand2.immediate = str2num(token.start,true);
.LINE 971

	LD	BC,1
	PUSH	BC
	LD	HL,IX
	LD	BC,-261
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_str2num
	POP	BC
	POP	BC
	LD	(_operand2+11),HL
	LD	A,E
	LD	(_operand2+14),A
;  972	                operand2.immediate_provided = true;
.LINE 972

	LD	A,%1
	LD	(_operand2+10),A
;  973	            }
;  974	            else error(message[ERROR_MISSINGOPERAND]);
.LINE 974

	JR	L_492
L_487:
	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  975	        }        
;  976	        else error(message[ERROR_MISSINGOPERAND]);
.LINE 976

	JR	L_492
L_489:
	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  977	    }
;  978	    else error(message[ERROR_MISSINGOPERAND]);
.LINE 978

	JR	L_492
L_491:
	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  979	}
L_492:
.LINE 979

	LD	SP,IX
	POP	IX
	RET	


;**************************** _parse_asm_keyval_pair ***************************
;Name                         Addr/Register   Size   Type
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_operand2                           IMPORT     16   variable
;_str2num                            IMPORT  -----   function
;_notEmpty                           IMPORT  -----   function
;_strcpy                             IMPORT  -----   function
;_getLineToken                       IMPORT  -----   function
;_currentline                        IMPORT    264   variable
;token                               IX-261    261   variable


; Stack Frame Size: 267 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "parse_asm_keyval_pair",979,"_parse_asm_keyval_pair"
;  980	
;  981	void handle_asm_db(void) {
_handle_asm_db:
.DEFINE "_handle_asm_db"

.VALUE _handle_asm_db

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "handle_asm_db",981,"_handle_asm_db"

.LINE 981

.DEFINE "token"

.CLASS 65

.VALUE -264

.TAG "NONAME11"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-264
	ADD	HL,SP
	LD	SP,HL
;  982	    tokentype token;
;  983	
;  984	    if(pass == 1) {
.LINE 984

	LD	BC,1
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_509
;  985	        // Output label at this address
;  986	        definelabel(address);
.LINE 986

	LD	A,(_address+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_address)
	PUSH	BC
	CALL	_definelabel
	POP	BC
	POP	BC
;  987	    }
L_509:
.LINE 987

;  988	    if(currentline.next) {
.LINE 988

	LD	HL,(_currentline+3)
	CALL	__icmpzero
	JR	NZ,L_505
	JR	L_508
;  989	        while(currentline.next) {
L_506:
.LINE 989

;  990	            getLineToken(&token, currentline.next, ',');
.LINE 990

	LD	BC,44
	PUSH	BC
	LD	BC,(_currentline+3)
	PUSH	BC
	LD	HL,IX
	LD	BC,-264
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
;  991	            if(notEmpty(token.start)) {
.LINE 991

	LD	HL,IX
	LD	BC,-264
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_notEmpty
	POP	BC
	OR	A,A
	JR	Z,L_504
;  992	                switch(token.start[0]) {
.LINE 992

	LD	HL,IX
	LD	BC,-264
	ADD	HL,BC
	LD	(IX+%FFFFFFFD),HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,34
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_495
;  993	                    case '\"':
.LINE 993

;  994	                        emit_quotedstring(token.start);
.LINE 994

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_emit_quotedstring
	POP	BC
;  995	                        break;
.LINE 995

	JR	L_504
;  996	                    default:
L_495:
.LINE 996

;  997	                        operand1.immediate = getLabelValue(token.start);
.LINE 997

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_getLabelValue
	POP	BC
	LD	(_operand1+11),HL
	LD	A,E
	LD	(_operand1+14),A
;  998	                        if(operand1.immediate > 0xff) error(message[WARNING_N_TOOLARGE]);
.LINE 998

	LD	HL,255
	LD	E,%0
	LD	BC,(_operand1+11)
	CALL	__lcmps
	JP	P,L_497
	LD	HL,_message+30
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_497:
;  999	                        emit_8bit(operand1.immediate);
.LINE 999

	LD	A,(_operand1+11)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
; 1000	                        break;
; 1001	                        
; 1002	                }
; 1003	            }
L_504:
.LINE 1003

; 1004	            if(token.terminator == ',') currentline.next = token.next;
.LINE 1004

	LD	A,(IX+%FFFFFFFC)
	CP	A,%2C
	JR	NZ,L_503
	LD	BC,(IX+%FFFFFFF9)
	LD	(_currentline+3),BC
; 1005	            else {
.LINE 1005

	JR	L_505
L_503:
; 1006	                if((token.terminator != 0) &&(token.terminator != ';')) error(message[ERROR_LISTFORMAT]);
.LINE 1006

	LD	A,(IX+%FFFFFFFC)
	OR	A,A
	JR	Z,L_501
	LD	A,(IX+%FFFFFFFC)
	CP	A,%3B
	JR	Z,L_501
	LD	HL,_message+90
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_501:
; 1007	                currentline.next = NULL; 
.LINE 1007

	LD	BC,0
	LD	(_currentline+3),BC
; 1008	            }
; 1009	        }
L_505:
.LINE 1009

	LD	HL,(_currentline+3)
	CALL	__icmpzero
	JR	NZ,L_506
	JR	L_510
; 1010	    }
; 1011	    else error(message[ERROR_MISSINGOPERAND]); // we need at least one value
L_508:
.LINE 1011

	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1012	}
L_510:
.LINE 1012

	LD	SP,IX
	POP	IX
	RET	


;**************************** _handle_asm_db ***************************
;Name                         Addr/Register   Size   Type
;_emit_8bit                          IMPORT  -----   function
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_operand1                           IMPORT     16   variable
;_notEmpty                           IMPORT  -----   function
;_getLineToken                       IMPORT  -----   function
;_currentline                        IMPORT    264   variable
;_address                            IMPORT      4   variable
;_pass                               IMPORT      3   variable
;token                               IX-264    261   variable
;G_23                                  IX-3      3   variable


; Stack Frame Size: 270 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "handle_asm_db",1012,"_handle_asm_db"
; 1013	
; 1014	void handle_asm_dw(bool longword) {
_handle_asm_dw:
.DEFINE "_handle_asm_dw"

.VALUE _handle_asm_dw

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "handle_asm_dw",1014,"_handle_asm_dw"

.LINE 1014

.DEFINE "longword"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "lbl"

.CLASS 65

.VALUE -3

.TAG "NONAME8"

.TYPE 40

.ENDEF

.DEFINE "token"

.CLASS 65

.VALUE -264

.TAG "NONAME11"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-264
	ADD	HL,SP
	LD	SP,HL
; 1015	    label *lbl;
; 1016	    tokentype token;
; 1017	    if(pass == 1) {
.LINE 1017

	LD	BC,1
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_530
; 1018	        // Output label at this address
; 1019	        definelabel(address);
.LINE 1019

	LD	A,(_address+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_address)
	PUSH	BC
	CALL	_definelabel
	POP	BC
	POP	BC
; 1020	    }
L_530:
.LINE 1020

; 1021	    if(currentline.next) {
.LINE 1021

	LD	HL,(_currentline+3)
	CALL	__icmpzero
	JR	NZ,L_526
	JR	L_529
; 1022	        while(currentline.next) {
L_527:
.LINE 1022

; 1023	            getLineToken(&token, currentline.next, ',');
.LINE 1023

	LD	BC,44
	PUSH	BC
	LD	BC,(_currentline+3)
	PUSH	BC
	LD	HL,IX
	LD	BC,-264
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
; 1024	            if(notEmpty(token.start)) {
.LINE 1024

	LD	HL,IX
	LD	BC,-264
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_notEmpty
	POP	BC
	OR	A,A
	JR	Z,L_525
; 1025	                lbl = findLabel(token.start);
.LINE 1025

	LD	HL,IX
	LD	BC,-264
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_findLabel
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 1026	                if(lbl) operand1.immediate = lbl->address;
.LINE 1026

	CALL	__icmpzero
	JR	Z,L_513
	LD	IY,(IX+%FFFFFFFD)
	LD	BC,(IY+%3)
	LD	A,(IY+%6)
	LD	(_operand1+11),BC
	LD	(_operand1+14),A
; 1027	                else operand1.immediate = str2num(token.start,true);
.LINE 1027

	JR	L_518
L_513:
	LD	BC,1
	PUSH	BC
	LD	HL,IX
	LD	BC,-264
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_str2num
	POP	BC
	POP	BC
	LD	(_operand1+11),HL
	LD	A,E
	LD	(_operand1+14),A
L_518:
; 1028	                
; 1029	                if(longword) {
.LINE 1029

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_517
; 1030	                    emit_24bit(operand1.immediate);
.LINE 1030

	LD	A,(_operand1+14)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_operand1+11)
	PUSH	BC
	CALL	_emit_24bit
	POP	BC
	POP	BC
; 1031	                }
; 1032	                else {
.LINE 1032

	JR	L_525
L_517:
; 1033	                    if(operand1.immediate > 0xffffff) error(message[ERROR_ADLWORDSIZE]);
.LINE 1033

	LD	HL,16777215
	LD	E,%0
	LD	BC,(_operand1+11)
	LD	A,(_operand1+14)
	CALL	__lcmps
	JP	P,L_515
	LD	HL,_message+84
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_515:
; 1034	                    emit_16bit(operand1.immediate);
.LINE 1034

	LD	BC,(_operand1+11)
	PUSH	BC
	CALL	_emit_16bit
	POP	BC
; 1035	                }
; 1036	            }
L_525:
.LINE 1036

; 1037	            if(token.terminator == ',') currentline.next = token.next;
.LINE 1037

	LD	A,(IX+%FFFFFFFC)
	CP	A,%2C
	JR	NZ,L_524
	LD	BC,(IX+%FFFFFFF9)
	LD	(_currentline+3),BC
; 1038	            else {
.LINE 1038

	JR	L_526
L_524:
; 1039	                if((token.terminator != 0) && (token.terminator != ';')) error(message[ERROR_LISTFORMAT]);
.LINE 1039

	LD	A,(IX+%FFFFFFFC)
	OR	A,A
	JR	Z,L_522
	LD	A,(IX+%FFFFFFFC)
	CP	A,%3B
	JR	Z,L_522
	LD	HL,_message+90
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_522:
; 1040	                currentline.next = NULL; 
.LINE 1040

	LD	BC,0
	LD	(_currentline+3),BC
; 1041	            }
; 1042	        }
L_526:
.LINE 1042

	LD	HL,(_currentline+3)
	CALL	__icmpzero
	JR	NZ,L_527
	JR	L_531
; 1043	    }
; 1044	    else error(message[ERROR_MISSINGOPERAND]); // we need at least one value
L_529:
.LINE 1044

	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1045	}
L_531:
.LINE 1045

	LD	SP,IX
	POP	IX
	RET	


;**************************** _handle_asm_dw ***************************
;Name                         Addr/Register   Size   Type
;_emit_16bit                         IMPORT  -----   function
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_emit_24bit                         IMPORT  -----   function
;_str2num                            IMPORT  -----   function
;_operand1                           IMPORT     16   variable
;_findLabel                          IMPORT  -----   function
;_notEmpty                           IMPORT  -----   function
;_getLineToken                       IMPORT  -----   function
;_currentline                        IMPORT    264   variable
;_address                            IMPORT      4   variable
;_pass                               IMPORT      3   variable
;token                               IX-264    261   variable
;lbl                                   IX-3      3   variable
;longword                              IX+6      1   parameter


; Stack Frame Size: 273 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "handle_asm_dw",1045,"_handle_asm_dw"
; 1046	
; 1047	void handle_asm_equ(void) {
_handle_asm_equ:
.DEFINE "_handle_asm_equ"

.VALUE _handle_asm_equ

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "handle_asm_equ",1047,"_handle_asm_equ"

.LINE 1047

.DEFINE "lbl"

.CLASS 65

.VALUE -3

.TAG "NONAME8"

.TYPE 40

.ENDEF

.DEFINE "token"

.CLASS 65

.VALUE -264

.TAG "NONAME11"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-264
	ADD	HL,SP
	LD	SP,HL
; 1048	    label *lbl;
; 1049	    tokentype token;
; 1050	
; 1051	    if(currentline.next) {
.LINE 1051

	LD	HL,(_currentline+3)
	CALL	__icmpzero
	JR	Z,L_543
; 1052	        getLineToken(&token, currentline.next, 0);
.LINE 1052

	LD	BC,0
	PUSH	BC
	LD	BC,(_currentline+3)
	PUSH	BC
	LD	HL,IX
	LD	BC,-264
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
; 1053	        if(notEmpty(token.start)) {
.LINE 1053

	LD	HL,IX
	LD	BC,-264
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_notEmpty
	POP	BC
	OR	A,A
	JR	Z,L_541
; 1054	            if((token.terminator != 0) && (token.terminator != ';')) error(message[ERROR_TOOMANYARGUMENTS]);
.LINE 1054

	LD	A,(IX+%FFFFFFFC)
	OR	A,A
	JR	Z,L_535
	LD	A,(IX+%FFFFFFFC)
	CP	A,%3B
	JR	Z,L_535
	LD	HL,_message+87
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_535:
; 1055	            if(pass == 1) definelabel(0);
.LINE 1055

	LD	BC,1
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_539
	LD	BC,0
	PUSH	BC
	PUSH	BC
	CALL	_definelabel
	POP	BC
	POP	BC
L_539:
; 1056	            if(pass == 2) {
.LINE 1056

	LD	BC,2
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_544
; 1057	                lbl = findLabel(currentline.label);
.LINE 1057

	LD	BC,_currentline+6
	PUSH	BC
	CALL	_findLabel
	POP	BC
	LD	(IX+%FFFFFFFD),HL
; 1058	                if(lbl) lbl->address = getLabelValue(token.start);
.LINE 1058

	CALL	__icmpzero
	JR	Z,L_537
	LD	HL,IX
	LD	BC,-264
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLabelValue
	POP	BC
	LD	IY,(IX+%FFFFFFFD)
	LD	(IY+%3),HL
	LD	(IY+%6),E
; 1059	                else error(message[ERROR_MISSINGLABEL]);
.LINE 1059

	JR	L_544
L_537:
	LD	HL,_message+81
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1060	            }
; 1061	        }
; 1062	        else error(message[ERROR_MISSINGOPERAND]);
.LINE 1062

	JR	L_544
L_541:
	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1063	    }
; 1064	    else error(message[ERROR_MISSINGOPERAND]);
.LINE 1064

	JR	L_544
L_543:
	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1065	}
L_544:
.LINE 1065

	LD	SP,IX
	POP	IX
	RET	


;**************************** _handle_asm_equ ***************************
;Name                         Addr/Register   Size   Type
;_findLabel                          IMPORT  -----   function
;_pass                               IMPORT      3   variable
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_notEmpty                           IMPORT  -----   function
;_getLineToken                       IMPORT  -----   function
;_currentline                        IMPORT    264   variable
;token                               IX-264    261   variable
;lbl                                   IX-3      3   variable


; Stack Frame Size: 270 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "handle_asm_equ",1065,"_handle_asm_equ"
; 1066	
; 1067	void handle_asm_adl(void) {
_handle_asm_adl:
.DEFINE "_handle_asm_adl"

.VALUE _handle_asm_adl

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "handle_asm_adl",1067,"_handle_asm_adl"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 1068	    parse_asm_keyval_pair();
.LINE 1068

	CALL	_parse_asm_keyval_pair
; 1069	    if(strcasecmp(currentline.operand1, "adl") == 0) {
.LINE 1069

	LD	BC,L__240
	PUSH	BC
	LD	BC,_currentline+70
	PUSH	BC
	CALL	_strcasecmp
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_549
; 1070	        if((operand2.immediate == 0) || (operand2.immediate == 1)) {
.LINE 1070

	LD	HL,(_operand2+11)
	LD	A,(_operand2+14)
	LD	E,A
	CALL	__lcmpzero
	JR	Z,L_546
	LD	HL,(_operand2+11)
	LD	A,(_operand2+14)
	LD	E,A
	LD	BC,1
	XOR	A,A
	CALL	__lcmps
	JR	NZ,L_547
L_546:
; 1071	            adlmode = operand2.immediate;
.LINE 1071

	LD	A,(_operand2+11)
	LD	(_adlmode),A
; 1072	        }
; 1073	        else error(message[ERROR_INVALID_ADLMODE]);
.LINE 1073

	JR	L_550
L_547:
	LD	HL,_message+51
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1074	    }
; 1075	    else error(message[ERROR_INVALIDOPERAND]);
.LINE 1075

	JR	L_550
L_549:
	LD	HL,_message+21
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1076	}
L_550:
.LINE 1076

	LD	SP,IX
	POP	IX
	RET	


;**************************** _handle_asm_adl ***************************
;Name                         Addr/Register   Size   Type
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_adlmode                            IMPORT      1   variable
;_operand2                           IMPORT     16   variable
;_currentline                        IMPORT    264   variable
;_strcasecmp                         IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "handle_asm_adl",1076,"_handle_asm_adl"
	SEGMENT STRSECT
L__240:
	DB	"adl"
	DB	0
	SEGMENT CODE
; 1077	
; 1078	void handle_asm_org(void) {
_handle_asm_org:
.DEFINE "_handle_asm_org"

.VALUE _handle_asm_org

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "handle_asm_org",1078,"_handle_asm_org"

.LINE 1078

.DEFINE "newaddress"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
; 1079	    uint32_t newaddress;
; 1080	    
; 1081	    parse_asm_single_immediate(); // get address from next token
.LINE 1081

	CALL	_parse_asm_single_immediate
; 1082	    newaddress = operand1.immediate;
.LINE 1082

	LD	BC,(_operand1+11)
	LD	A,(_operand1+14)
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 1083	    if((adlmode == 0) && (newaddress > 0xffff)) error(message[ERROR_ADDRESSRANGE]); 
.LINE 1083

	LD	A,(_adlmode)
	OR	A,A
	JR	NZ,L_557
	LD	HL,65535
	LD	E,%0
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	CALL	__lcmpu
	JR	NC,L_557
	LD	HL,_message+60
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_557:
; 1084	    if(newaddress >= address) {
.LINE 1084

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,(_address)
	LD	A,(_address+3)
	CALL	__lcmpu
	JR	C,L_556
; 1085	        if(pass == 1) {
.LINE 1085

	LD	BC,1
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_554
; 1086	            // Output label at this address
; 1087	            definelabel(address); // set address to current line
.LINE 1087

	LD	A,(_address+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_address)
	PUSH	BC
	CALL	_definelabel
	POP	BC
	POP	BC
; 1088	        }
L_554:
.LINE 1088

; 1089	        address = newaddress;
.LINE 1089

	LD	BC,(IX+%FFFFFFFC)
	LD	(_address),BC
	LD	A,(IX+%FFFFFFFF)
	LD	(_address+3),A
; 1090	    }
; 1091	    else error(message[ERROR_ADDRESSLOWER]);
.LINE 1091

	JR	L_558
L_556:
	LD	HL,_message+57
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1092	}
L_558:
.LINE 1092

	LD	SP,IX
	POP	IX
	RET	


;**************************** _handle_asm_org ***************************
;Name                         Addr/Register   Size   Type
;_pass                               IMPORT      3   variable
;_address                            IMPORT      4   variable
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_adlmode                            IMPORT      1   variable
;_operand1                           IMPORT     16   variable
;newaddress                            IX-4      4   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "handle_asm_org",1092,"_handle_asm_org"
; 1093	
; 1094	void handle_asm_include(void) {
_handle_asm_include:
.DEFINE "_handle_asm_include"

.VALUE _handle_asm_include

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "handle_asm_include",1094,"_handle_asm_include"

.LINE 1094

.DEFINE "fsi"

.CLASS 65

.VALUE -134

.TAG "NONAME12"

.TYPE 8

.ENDEF

.DEFINE "token"

.CLASS 65

.VALUE -395

.TAG "NONAME11"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-398
	ADD	HL,SP
	LD	SP,HL
; 1095	    tokentype token;
; 1096	    filestackitem fsi;
; 1097	    if(currentline.next) {
.LINE 1097

	LD	HL,(_currentline+3)
	CALL	__icmpzero
	JR	Z,L_566
; 1098	        getLineToken(&token, currentline.next, 0);
.LINE 1098

	LD	BC,0
	PUSH	BC
	LD	BC,(_currentline+3)
	PUSH	BC
	LD	HL,IX
	LD	BC,-395
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
; 1099	        if(token.start[0] == '\"') {
.LINE 1099

	LD	HL,IX
	LD	BC,-395
	ADD	HL,BC
	LD	(IX+%FFFFFFFD),HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,34
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_562
; 1100	            token.start[strlen(token.start)-1] = 0;
.LINE 1100

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	BC,(IX+%FFFFFFFD)
	ADD	HL,BC
	DEC	HL
	LD	(HL),%0
; 1101	            fsi.linenumber = linenumber;
.LINE 1101

	LD	BC,(_linenumber)
	LEA	IY,IX+%FFFFFF80
	LD	(IY+%FFFFFFFA),C
	LD	(IY+%FFFFFFFB),B
; 1102	            fsi.fp = filehandle[FILE_CURRENT];
.LINE 1102

	LD	A,(_filehandle)
	LD	(IY+%FFFFFFFC),A
; 1103	            strcpy(fsi.filename, filename[FILE_CURRENT]);
.LINE 1103

	LD	BC,_filename
	PUSH	BC
	LD	HL,IX
	LD	BC,-131
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
; 1104	            filestackPush(&fsi);
.LINE 1104

	LD	HL,IX
	LD	BC,-134
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_filestackPush
	POP	BC
; 1105	            filehandle[FILE_CURRENT] = mos_fopen(token.start+1, fa_read);
.LINE 1105

	LD	HL,(IX+%FFFFFFFD)
	INC	HL
	LD	BC,-398
	CALL	__istix
	LD	BC,1
	PUSH	BC
	LD	BC,-398
	CALL	__ildix
	PUSH	HL
	CALL	_mos_fopen
	POP	BC
	POP	BC
	LD	(_filehandle),A
; 1106	            strcpy(filename[FILE_CURRENT], token.start+1);
.LINE 1106

	LD	BC,-398
	CALL	__ildix
	PUSH	HL
	LD	BC,_filename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
; 1107	            if(filehandle[FILE_CURRENT] == NULL) {
.LINE 1107

	LD	A,(_filehandle)
	OR	A,A
	JR	NZ,L_560
; 1108	                filestackPop(&fsi);
.LINE 1108

	LD	HL,IX
	LD	BC,-134
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_filestackPop
	POP	BC
; 1109	                error(message[ERROR_INCLUDEFILE]);
.LINE 1109

	LD	HL,_message+102
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1110	            }
L_560:
.LINE 1110

; 1111	            lineNumberNeedsReset = true;
.LINE 1111

	LD	A,%1
	LD	(_lineNumberNeedsReset),A
; 1112	        }
; 1113	        else error(message[ERROR_STRINGFORMAT]);
.LINE 1113

	JR	L_564
L_562:
	LD	HL,_message+63
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_564:
; 1114	        if(token.terminator != 0) error(message[ERROR_TOOMANYARGUMENTS]);
.LINE 1114

	LEA	IY,IX+%FFFFFF80
	LD	A,(IY+%FFFFFFF9)
	OR	A,A
	JR	Z,L_567
	LD	HL,_message+87
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1115	    }
; 1116	    else error(message[ERROR_MISSINGOPERAND]);
.LINE 1116

	JR	L_567
L_566:
	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1117	}
L_567:
.LINE 1117

	LD	SP,IX
	POP	IX
	RET	


;**************************** _handle_asm_include ***************************
;Name                         Addr/Register   Size   Type
;_lineNumberNeedsReset               IMPORT      1   variable
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_filestackPop                       IMPORT  -----   function
;_mos_fopen                          IMPORT  -----   function
;_filestackPush                      IMPORT  -----   function
;_filename                           IMPORT    768   variable
;_strcpy                             IMPORT  -----   function
;_filehandle                         IMPORT      6   variable
;_linenumber                         IMPORT      3   variable
;_strlen                             IMPORT  -----   function
;_getLineToken                       IMPORT  -----   function
;_currentline                        IMPORT    264   variable
;token                               IX-395    261   variable
;fsi                                 IX-134    131   variable
;G_25                                  IX-3      3   variable


; Stack Frame Size: 404 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "handle_asm_include",1117,"_handle_asm_include"
; 1118	
; 1119	
; 1120	
; 1121	void handle_asm_blk(uint8_t width) {
_handle_asm_blk:
.DEFINE "_handle_asm_blk"

.VALUE _handle_asm_blk

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "handle_asm_blk",1121,"_handle_asm_blk"

.LINE 1121

.DEFINE "width"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "val"

.CLASS 65

.VALUE -4

.TYPE 5

.ENDEF

.DEFINE "num"

.CLASS 65

.VALUE -6

.TYPE 13

.ENDEF

.DEFINE "token"

.CLASS 65

.VALUE -270

.TAG "NONAME11"

.TYPE 8

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-270
	ADD	HL,SP
	LD	SP,HL
; 1122	    uint16_t num;
; 1123	    int32_t val = 0;
.LINE 1123

	LD	BC,0
	XOR	A,A
	LD	(IX+%FFFFFFFC),BC
	LD	(IX+%FFFFFFFF),A
; 1124	    tokentype token;
; 1125	
; 1126	    if(pass == 1) {
.LINE 1126

	LD	BC,1
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_589
; 1127	        // Output label at this address
; 1128	        definelabel(address);
.LINE 1128

	LD	A,(_address+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_address)
	PUSH	BC
	CALL	_definelabel
	POP	BC
	POP	BC
; 1129	    }
L_589:
.LINE 1129

; 1130	
; 1131	    if(currentline.next) {
.LINE 1131

	LD	HL,(_currentline+3)
	CALL	__icmpzero
	JR	Z,L_588
; 1132	        getLineToken(&token, currentline.next, ',');
.LINE 1132

	LD	BC,44
	PUSH	BC
	LD	BC,(_currentline+3)
	PUSH	BC
	LD	HL,IX
	LD	BC,-270
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
; 1133	        if(notEmpty(token.start)) {
.LINE 1133

	LD	HL,IX
	LD	BC,-270
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_notEmpty
	POP	BC
	OR	A,A
	JR	Z,L_586
; 1134	            num = str2num(token.start,true);
.LINE 1134

	LD	BC,1
	PUSH	BC
	LD	HL,IX
	LD	BC,-270
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_str2num
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
; 1135	
; 1136	            if(token.terminator == ',') {
.LINE 1136

	LD	A,(IX+%FFFFFFF6)
	CP	A,%2C
	JR	NZ,L_576
; 1137	                getLineToken(&token, token.next, 0);
.LINE 1137

	LD	BC,0
	PUSH	BC
	LD	BC,(IX+%FFFFFFF3)
	PUSH	BC
	LD	HL,IX
	LD	BC,-270
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_getLineToken
	POP	BC
	POP	BC
	POP	BC
; 1138	                if(notEmpty(token.start)) {
.LINE 1138

	LD	HL,IX
	LD	BC,-270
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_notEmpty
	POP	BC
	OR	A,A
	JR	Z,L_572
; 1139	                    if(token.start[0] == '\'') val = getAsciiValue(token.start);
.LINE 1139

	LD	HL,IX
	LD	BC,-270
	ADD	HL,BC
	LD	(IX+%FFFFFFF7),HL
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,39
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_570
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	CALL	_getAsciiValue
	POP	BC
	UEXT	HL
	LD	L,A
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),H
; 1140	                    else val = str2num(token.start,true);
.LINE 1140

	JR	L_582
L_570:
	LD	BC,1
	PUSH	BC
	LD	BC,(IX+%FFFFFFF7)
	PUSH	BC
	CALL	_str2num
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 1141	                }
; 1142	                else error(message[ERROR_MISSINGOPERAND]);
.LINE 1142

	JR	L_582
L_572:
	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1143	            }
; 1144	            else if((token.terminator != 0)  && (token.terminator != ';')) error(message[ERROR_LISTFORMAT]);
.LINE 1144

	JR	L_582
L_576:
	LD	A,(IX+%FFFFFFF6)
	OR	A,A
	JR	Z,L_582
	LD	A,(IX+%FFFFFFF6)
	CP	A,%3B
	JR	Z,L_582
	LD	HL,_message+90
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1145	            while(num--) {
.LINE 1145

	JR	L_582
L_583:
; 1146	                switch(width) {
.LINE 1146

	LD	A,(IX+%6)
	UEXT	HL
	LD	L,A
	CALL	__seqcaseD
	JP	(HL)
L__263:
	DW	4
	DW	1
	DB	0
	DW24	L_578	

	DW24	L_579	

	DW24	L_580	

	DW24	L_581	

	DW24	L_582	

; 1147	                    case 1:
L_578:
.LINE 1147

; 1148	                        emit_8bit(val);
.LINE 1148

	LD	C,(IX+%FFFFFFFC)
	LD	B,%0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
; 1149	                        break;
.LINE 1149

	JR	L_582
; 1150	                    case 2:
L_579:
.LINE 1150

; 1151	                        emit_16bit(val);
.LINE 1151

	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	CALL	_emit_16bit
	POP	BC
; 1152	                        break;
.LINE 1152

	JR	L_582
; 1153	                    case 3:
L_580:
.LINE 1153

; 1154	                        emit_24bit(val);
.LINE 1154

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	CALL	_emit_24bit
	POP	BC
	POP	BC
; 1155	                        break;
.LINE 1155

	JR	L_582
; 1156	                    case 4:
L_581:
.LINE 1156

; 1157	                        emit_32bit(val);
.LINE 1157

	LD	C,(IX+%FFFFFFFF)
	LD	B,%0
	PUSH	BC
	LD	BC,(IX+%FFFFFFFC)
	PUSH	BC
	CALL	_emit_32bit
	POP	BC
	POP	BC
; 1158	                        break;
; 1159	                }
; 1160	            }
L_582:
.LINE 1160

	LD	BC,(IX+%FFFFFFFA)
	LD	IY,(IX+%FFFFFFFA)
	LEA	HL,IY+%FFFFFFFF
	LD	(IX+%FFFFFFFA),L
	LD	(IX+%FFFFFFFB),H
	LD	HL,BC
	CALL	__scmpzero
	JR	NZ,L_583
	JR	L_590
; 1161	        }
; 1162	        else error(message[ERROR_MISSINGOPERAND]); // we need at least one value
L_586:
.LINE 1162

	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1163	    }
; 1164	    else error(message[ERROR_MISSINGOPERAND]); // we need at least one value
.LINE 1164

	JR	L_590
L_588:
	LD	HL,_message+15
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1165	}
L_590:
.LINE 1165

	LD	SP,IX
	POP	IX
	RET	


;**************************** _handle_asm_blk ***************************
;Name                         Addr/Register   Size   Type
;_emit_24bit                         IMPORT  -----   function
;_emit_16bit                         IMPORT  -----   function
;_emit_8bit                          IMPORT  -----   function
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_str2num                            IMPORT  -----   function
;_notEmpty                           IMPORT  -----   function
;_getLineToken                       IMPORT  -----   function
;_currentline                        IMPORT    264   variable
;_address                            IMPORT      4   variable
;_pass                               IMPORT      3   variable
;token                               IX-270    261   variable
;G_27                                  IX-9      3   variable
;num                                   IX-6      2   variable
;val                                   IX-4      4   variable
;width                                 IX+6      1   parameter


; Stack Frame Size: 279 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "handle_asm_blk",1165,"_handle_asm_blk"
; 1166	
; 1167	void handle_asm_align(void) {
_handle_asm_align:
.DEFINE "_handle_asm_align"

.VALUE _handle_asm_align

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "handle_asm_align",1167,"_handle_asm_align"

.LINE 1167

.DEFINE "base"

.CLASS 65

.VALUE -4

.TYPE 15

.ENDEF

.DEFINE "delta"

.CLASS 65

.VALUE -8

.TYPE 15

.ENDEF

.DEFINE "alignment"

.CLASS 65

.VALUE -12

.TYPE 15

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEC
	LD	SP,HL
; 1168	uint32_t alignment;
; 1169	uint32_t base;
; 1170	uint32_t delta;
; 1171	
; 1172	    if(pass == 1) {
.LINE 1172

	LD	BC,1
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_592
; 1173	        // Output label at this address
; 1174	        definelabel(address);
.LINE 1174

	LD	A,(_address+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_address)
	PUSH	BC
	CALL	_definelabel
	POP	BC
	POP	BC
; 1175	    }
L_592:
.LINE 1175

; 1176	
; 1177	    parse_asm_single_immediate();
.LINE 1177

	CALL	_parse_asm_single_immediate
; 1178	    if(operand1.immediate > 0) {
.LINE 1178

	OR	A,A
	SBC	HL,HL
	LD	E,%0
	LD	BC,(_operand1+11)
	LD	A,(_operand1+14)
	CALL	__lcmps
	JP	P,L_603
; 1179	        if((operand1.immediate & (operand1.immediate - 1)) == 0) {
.LINE 1179

	LD	HL,(_operand1+11)
	LD	A,(_operand1+14)
	LD	E,A
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	BC,(_operand1+11)
	LD	A,(_operand1+14)
	CALL	__land
	CALL	__lcmpzero
	JR	NZ,L_601
; 1180	            alignment = operand1.immediate;
.LINE 1180

	LD	BC,(_operand1+11)
	LD	A,(_operand1+14)
	LD	(IX+%FFFFFFF4),BC
	LD	(IX+%FFFFFFF7),A
; 1181	            base = (~(operand1.immediate - 1) & address);
.LINE 1181

	LD	HL,(_operand1+11)
	LD	A,(_operand1+14)
	LD	E,A
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	CALL	__lnot
	LD	BC,(_address)
	LD	A,(_address+3)
	CALL	__land
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
; 1182	
; 1183	            if(address & (operand1.immediate -1)) base += alignment;
.LINE 1183

	LD	HL,(_operand1+11)
	LD	A,(_operand1+14)
	LD	E,A
	LD	BC,16777215
	LD	A,%FF
	CALL	__ladd
	LD	BC,(_address)
	LD	A,(_address+3)
	CALL	__land
	CALL	__lcmpzero
	JR	Z,L_594
	LD	HL,(IX+%FFFFFFF4)
	LD	E,(IX+%FFFFFFF7)
	LD	BC,(IX+%FFFFFFFC)
	LD	A,(IX+%FFFFFFFF)
	CALL	__ladd
	LD	(IX+%FFFFFFFC),HL
	LD	(IX+%FFFFFFFF),E
L_594:
; 1184	            delta = base - address;
.LINE 1184

	LD	HL,(IX+%FFFFFFFC)
	LD	E,(IX+%FFFFFFFF)
	LD	BC,(_address)
	LD	A,(_address+3)
	CALL	__lsub
	LD	(IX+%FFFFFFF8),HL
	LD	(IX+%FFFFFFFB),E
; 1185	            while(delta--) emit_8bit(FILLBYTE);
.LINE 1185

	JR	L_596
L_597:
	LD	BC,0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
L_596:
	LD	BC,(IX+%FFFFFFF8)
	LD	(IX+%FFFFFFEC),BC	; spill
	LD	H,(IX+%FFFFFFFB)
	LD	(IX+%FFFFFFF2),H	; spill
	LD	HL,(IX+%FFFFFFF8)
	LD	E,(IX+%FFFFFFFB)
	LD	BC,1
	XOR	A,A
	CALL	__lsub
	LD	(IX+%FFFFFFF8),HL
	LD	(IX+%FFFFFFFB),E
	LD	H,(IX+%FFFFFFF2)	; unspill
	LD	E,H
	LD	HL,(IX+%FFFFFFEC)
	CALL	__lcmpzero
	JR	NZ,L_597
; 1186	
; 1187	            address = base;
.LINE 1187

	LD	BC,(IX+%FFFFFFFC)
	LD	(_address),BC
	LD	A,(IX+%FFFFFFFF)
	LD	(_address+3),A
; 1188	            if(pass == 1) {
.LINE 1188

	LD	BC,1
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_604
; 1189	                definelabel(address); // set address to current line
.LINE 1189

	LD	A,(_address+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_address)
	PUSH	BC
	CALL	_definelabel
	POP	BC
	POP	BC
; 1190	            }
; 1191	        }
; 1192	        else error(message[ERROR_POWER2]); 
.LINE 1192

	JR	L_604
L_601:
	LD	HL,_message+117
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1193	    }
; 1194	    else error(message[ERROR_INVALIDNUMBER]);
.LINE 1194

	JR	L_604
L_603:
	LD	HL,_message+9
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1195	}
L_604:
.LINE 1195

	LD	SP,IX
	POP	IX
	RET	


;**************************** _handle_asm_align ***************************
;Name                         Addr/Register   Size   Type
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_emit_8bit                          IMPORT  -----   function
;_operand1                           IMPORT     16   variable
;_address                            IMPORT      4   variable
;_pass                               IMPORT      3   variable
;alignment                            IX-12      4   variable
;delta                                 IX-8      4   variable
;base                                  IX-4      4   variable


; Stack Frame Size: 26 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "handle_asm_align",1195,"_handle_asm_align"
; 1196	
; 1197	void handle_assembler_command(void) {
_handle_assembler_command:
.DEFINE "_handle_assembler_command"

.VALUE _handle_assembler_command

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "handle_assembler_command",1197,"_handle_assembler_command"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 1198	    switch(currentline.current_instruction->asmtype) {
.LINE 1198

	LD	IY,(_currentline)
	LD	A,(IY+%9)
	UEXT	HL
	LD	L,A
	CALL	__seqcaseD
	JP	(HL)
L__273:
	DW	14
	DW	0
	DB	0
	DW24	L_618	

	DW24	L_605	

	DW24	L_606	

	DW24	L_607	

	DW24	L_608	

	DW24	L_609	

	DW24	L_610	

	DW24	L_611	

	DW24	L_612	

	DW24	L_613	

	DW24	L_614	

	DW24	L_615	

	DW24	L_616	

	DW24	L_617	

	DW24	L_619	

; 1199	    case(ASM_ADL):
L_605:
.LINE 1199

; 1200	        handle_asm_adl();
.LINE 1200

	CALL	_handle_asm_adl
; 1201	        break;
.LINE 1201

	JR	L_619
; 1202	    case(ASM_ORG):
L_606:
.LINE 1202

; 1203	        handle_asm_org();
.LINE 1203

	CALL	_handle_asm_org
; 1204	        break;
.LINE 1204

	JR	L_619
; 1205	    case(ASM_DB):
L_607:
.LINE 1205

; 1206	        handle_asm_db();
.LINE 1206

	CALL	_handle_asm_db
; 1207	        break;
.LINE 1207

	JR	L_619
; 1208	    case(ASM_DS):
L_608:
.LINE 1208

; 1209	        handle_asm_blk(1);
.LINE 1209

	LD	BC,1
	PUSH	BC
	CALL	_handle_asm_blk
	POP	BC
; 1210	        break;
.LINE 1210

	JR	L_619
; 1211	    case(ASM_DW):
L_609:
.LINE 1211

; 1212	        handle_asm_dw(false);
.LINE 1212

	LD	BC,0
	PUSH	BC
	CALL	_handle_asm_dw
	POP	BC
; 1213	        break;
.LINE 1213

	JR	L_619
; 1214	    case(ASM_DW24):
L_610:
.LINE 1214

; 1215	        handle_asm_dw(true);
.LINE 1215

	LD	BC,1
	PUSH	BC
	CALL	_handle_asm_dw
	POP	BC
; 1216	        break;
.LINE 1216

	JR	L_619
; 1217	    case(ASM_ASCIZ):
L_611:
.LINE 1217

; 1218	        handle_asm_db();
.LINE 1218

	CALL	_handle_asm_db
; 1219	        emit_8bit(0);
.LINE 1219

	LD	BC,0
	PUSH	BC
	CALL	_emit_8bit
	POP	BC
; 1220	        break;
.LINE 1220

	JR	L_619
; 1221	    case(ASM_EQU):
L_612:
.LINE 1221

; 1222	        handle_asm_equ();
.LINE 1222

	CALL	_handle_asm_equ
; 1223	        break;
.LINE 1223

	JR	L_619
; 1224	    case(ASM_INCLUDE):
L_613:
.LINE 1224

; 1225	        handle_asm_include();
.LINE 1225

	CALL	_handle_asm_include
; 1226	        break;
.LINE 1226

	JR	L_619
; 1227	    case(ASM_BLKB):
L_614:
.LINE 1227

; 1228	        handle_asm_blk(1);
.LINE 1228

	LD	BC,1
	PUSH	BC
	CALL	_handle_asm_blk
	POP	BC
; 1229	        break;
.LINE 1229

	JR	L_619
; 1230	    case(ASM_BLKW):
L_615:
.LINE 1230

; 1231	        handle_asm_blk(2);
.LINE 1231

	LD	BC,2
	PUSH	BC
	CALL	_handle_asm_blk
	POP	BC
; 1232	        break;
.LINE 1232

	JR	L_619
; 1233	    case(ASM_BLKP):
L_616:
.LINE 1233

; 1234	        handle_asm_blk(3);
.LINE 1234

	LD	BC,3
	PUSH	BC
	CALL	_handle_asm_blk
	POP	BC
; 1235	        break;
.LINE 1235

	JR	L_619
; 1236	    case(ASM_BLKL):
L_617:
.LINE 1236

; 1237	        handle_asm_blk(4);
.LINE 1237

	LD	BC,4
	PUSH	BC
	CALL	_handle_asm_blk
	POP	BC
; 1238	        break;
.LINE 1238

	JR	L_619
; 1239	    case(ASM_ALIGN):
L_618:
.LINE 1239

; 1240	        handle_asm_align();
.LINE 1240

	CALL	_handle_asm_align
; 1241	        break;
; 1242	    }
L_619:
.LINE 1242

; 1243	    return;
; 1244	}
.LINE 1244

	LD	SP,IX
	POP	IX
	RET	


;**************************** _handle_assembler_command ***************************
;Name                         Addr/Register   Size   Type
;_emit_8bit                          IMPORT  -----   function
;_currentline                        IMPORT    264   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "handle_assembler_command",1244,"_handle_assembler_command"
; 1245	
; 1246	void processInstructions(void){
_processInstructions:
.DEFINE "_processInstructions"

.VALUE _processInstructions

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "processInstructions",1246,"_processInstructions"

.LINE 1246

.DEFINE "list"

.CLASS 65

.VALUE -3

.TAG "NONAME5"

.TYPE 40

.ENDEF

.DEFINE "listitem"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

.DEFINE "match"

.CLASS 65

.VALUE -5

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
	DEC	SP
; 1247	    operandlist *list;
; 1248	    uint8_t listitem;
; 1249	    bool match;
; 1250	
; 1251	    // return on empty lines
; 1252	    if(isEmpty(currentline.mnemonic)) {
.LINE 1252

	LD	BC,_currentline+38
	PUSH	BC
	CALL	_isEmpty
	POP	BC
	OR	A,A
	JR	Z,L_638
; 1253	        // check if there is a single label on a line in during pass 1
; 1254	        if(pass == 1) definelabel(address);
.LINE 1254

	LD	BC,1
	LD	HL,(_pass)
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_640
	LD	A,(_address+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(_address)
	PUSH	BC
	CALL	_definelabel
	POP	BC
	POP	BC
; 1255	        return; // valid line, but empty
.LINE 1255

	JR	L_640
; 1256	    }
L_638:
.LINE 1256

; 1257	
; 1258	    if(currentline.current_instruction) {
.LINE 1258

	LD	HL,(_currentline)
	CALL	__icmpzero
	JR	Z,L_639
; 1259	        if(currentline.current_instruction->type == EZ80) {
.LINE 1259

	LD	IY,(_currentline)
	LD	A,(IY+%8)
	OR	A,A
	JR	NZ,L_636
; 1260	            // process this mnemonic by applying the instruction list as a filter to the operand-set
; 1261	            list = currentline.current_instruction->list;
.LINE 1261

	LD	IY,(_currentline)
	LD	BC,(IY+%B)
	LD	(IX+%FFFFFFFD),BC
; 1262	            match = false;
.LINE 1262

	LD	(IX+%FFFFFFFB),%0
; 1263	            for(listitem = 0; listitem < currentline.current_instruction->listnumber; listitem++) {
.LINE 1263

	LD	(IX+%FFFFFFFC),%0
	JR	L_631
L_629:
; 1264	                if(permittype_matchlist[list->operandA].match(&operand1) && permittype_matchlist[list->operandB].match(&operand2)) {
.LINE 1264

	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%0)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,_permittype_matchlist
	ADD	HL,BC
	LD	IY,HL
	LD	IY,(IY+%3)
	LD	BC,_operand1
	PUSH	BC
	CALL	__indcall
	POP	BC
	OR	A,A
	JR	Z,L_628
	LD	IY,(IX+%FFFFFFFD)
	LD	HL,(IY+%3)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,HL
	ADD	HL,BC
	ADD	HL,BC
	LD	BC,_permittype_matchlist
	ADD	HL,BC
	LD	IY,HL
	LD	IY,(IY+%3)
	LD	BC,_operand2
	PUSH	BC
	CALL	__indcall
	POP	BC
	OR	A,A
	JR	Z,L_628
; 1265	                    match = true;
.LINE 1265

	LD	(IX+%FFFFFFFB),%1
; 1266	                    emit_instruction(list);
.LINE 1266

	LD	BC,(IX+%FFFFFFFD)
	PUSH	BC
	CALL	_emit_instruction
	POP	BC
; 1267	                    break;
.LINE 1267

	JR	L_633
; 1268	                }
L_628:
.LINE 1268

; 1269	                list++;
.LINE 1269

	LD	IY,(IX+%FFFFFFFD)
	LEA	IY,IY+%10
	LD	(IX+%FFFFFFFD),IY
	INC	(IX+%FFFFFFFC)
; 1270	            }
L_631:
.LINE 1270

	LD	IY,(_currentline)
	LD	A,(IX+%FFFFFFFC)
	CP	A,(IY+%A)
	JR	C,L_629
L_633:
; 1271	            if(!match) error(message[ERROR_OPERANDSNOTMATCHING]);
.LINE 1271

	LD	A,(IX+%FFFFFFFB)
	OR	A,A
	JR	NZ,L_640
	LD	HL,_message+24
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
; 1272	            return;
.LINE 1272

	JR	L_640
; 1273	        }
; 1274	        else handle_assembler_command();
L_636:
.LINE 1274

	CALL	_handle_assembler_command
; 1275	    }
L_639:
.LINE 1275

; 1276	    return;
; 1277	}
L_640:
.LINE 1277

	LD	SP,IX
	POP	IX
	RET	


;**************************** _processInstructions ***************************
;Name                         Addr/Register   Size   Type
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;_operand2                           IMPORT     16   variable
;_operand1                           IMPORT     16   variable
;_permittype_matchlist               IMPORT  unknown variable
;_address                            IMPORT      4   variable
;_pass                               IMPORT      3   variable
;_currentline                        IMPORT    264   variable
;_isEmpty                            IMPORT  -----   function
;match                                 IX-5      1   variable
;listitem                              IX-4      1   variable
;list                                  IX-3      3   variable


; Stack Frame Size: 11 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "processInstructions",1277,"_processInstructions"
; 1278	
; 1279	void passInitialize(uint8_t passnumber) {
_passInitialize:
.DEFINE "_passInitialize"

.VALUE _passInitialize

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "passInitialize",1279,"_passInitialize"

.LINE 1279

.DEFINE "passnumber"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 1280	    pass = passnumber;
.LINE 1280

	LD	A,(IX+%6)
	UEXT	HL
	LD	L,A
	LD	(_pass),HL
; 1281	    adlmode = true;
.LINE 1281

	LD	A,%1
	LD	(_adlmode),A
; 1282	    linenumber = 0;
.LINE 1282

	LD	BC,0
	LD	(_linenumber),BC
; 1283	    address = START_ADDRESS;
.LINE 1283

	XOR	A,A
	LD	(_address),BC
	LD	(_address+3),A
; 1284	    totalsize = 0;
.LINE 1284

	XOR	A,A
	LD	(_totalsize),BC
	LD	(_totalsize+3),A
; 1285	    
; 1286	    // init the file stack and push the primary input file
; 1287	    filestackInit();
.LINE 1287

	CALL	_filestackInit
; 1288	}
.LINE 1288

	LD	SP,IX
	POP	IX
	RET	


;**************************** _passInitialize ***************************
;Name                         Addr/Register   Size   Type
;_filestackInit                      IMPORT  -----   function
;_totalsize                          IMPORT      4   variable
;_address                            IMPORT      4   variable
;_linenumber                         IMPORT      3   variable
;_adlmode                            IMPORT      1   variable
;_pass                               IMPORT      3   variable
;passnumber                            IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "passInitialize",1288,"_passInitialize"
; 1289	
; 1290	// Assembler directives may demand a late reset of the linenumber, after the listing has been done
; 1291	void processDelayedLineNumberReset(void) {
_processDelayedLineNumberReset:
.DEFINE "_processDelayedLineNumberReset"

.VALUE _processDelayedLineNumberReset

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "processDelayedLineNumberReset",1291,"_processDelayedLineNumberReset"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
; 1292	    if(lineNumberNeedsReset) {
.LINE 1292

	LD	A,(_lineNumberNeedsReset)
	OR	A,A
	JR	Z,L_643
; 1293	        lineNumberNeedsReset = false;
.LINE 1293

	XOR	A,A
	LD	(_lineNumberNeedsReset),A
; 1294	        linenumber = 0;
.LINE 1294

	LD	BC,0
	LD	(_linenumber),BC
; 1295	    }
; 1296	}
L_643:
.LINE 1296

	LD	SP,IX
	POP	IX
	RET	


;**************************** _processDelayedLineNumberReset ***************************
;Name                         Addr/Register   Size   Type
;_linenumber                         IMPORT      3   variable
;_lineNumberNeedsReset               IMPORT      1   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "processDelayedLineNumberReset",1296,"_processDelayedLineNumberReset"
; 1297	
; 1298	bool assemble(void){
_assemble:
.DEFINE "_assemble"

.VALUE _assemble

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "assemble",1298,"_assemble"

.LINE 1298

.DEFINE "incfiles"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "fsitem"

.CLASS 65

.VALUE -132

.TAG "NONAME12"

.TYPE 8

.ENDEF

.DEFINE "line"

.CLASS 65

.VALUE -260

.DIM 128

.TYPE 98

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LD	HL,-260
	ADD	HL,SP
	LD	SP,HL
; 1299	    char line[LINEMAX];
; 1300	    filestackitem fsitem;
; 1301	    bool incfiles;
; 1302	
; 1303	    global_errors = 0;
.LINE 1303

	LD	HL,_global_errors
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
; 1304	
; 1305	    filehandle[FILE_CURRENT] = filehandle[FILE_INPUT];
.LINE 1305

	LD	HL,_filehandle
	INC	HL
	LD	A,(HL)
	LD	(_filehandle),A
; 1306	    strcpy(filename[FILE_CURRENT], filename[FILE_INPUT]);
.LINE 1306

	LD	BC,128
	LD	HL,_filename
	ADD	HL,BC
	PUSH	HL
	LD	BC,_filename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
; 1307	
; 1308	    // Assemble in two passes
; 1309	    // Pass 1
; 1310	    printf("Pass 1...\n\r");
.LINE 1310

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__287
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
; 1311	    passInitialize(1);
.LINE 1311

	LD	BC,1
	PUSH	BC
	CALL	_passInitialize
	POP	BC
; 1312	    do {
; 1313	        while (agon_fgets(line, sizeof(line), FILE_CURRENT)){
.LINE 1313

	JR	L_645
L_646:
; 1314	            linenumber++;
.LINE 1314

	LD	BC,(_linenumber)
	INC	BC
	LD	(_linenumber),BC
; 1315	            parseLine(line);
.LINE 1315

	LD	HL,IX
	LD	BC,-260
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_parseLine
	POP	BC
; 1316	            processInstructions();
.LINE 1316

	CALL	_processInstructions
; 1317	            processDelayedLineNumberReset();
.LINE 1317

	CALL	_processDelayedLineNumberReset
; 1318	
; 1319	            //printLocalLabelTable();
; 1320	
; 1321	        }
L_645:
.LINE 1321

	LD	BC,0
	PUSH	BC
	LD	BC,128
	PUSH	BC
	LD	HL,IX
	LD	BC,-260
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_agon_fgets
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_646
; 1322	        if(filestackCount()) {
.LINE 1322

	CALL	_filestackCount
	OR	A,A
	JR	Z,L_648
; 1323	            mos_fclose(filehandle[FILE_CURRENT]);
.LINE 1323

	LD	A,(_filehandle)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
; 1324	            incfiles = filestackPop(&fsitem);
.LINE 1324

	LD	HL,IX
	LD	BC,-132
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_filestackPop
	POP	BC
	LD	(IX+%FFFFFFFF),A
; 1325	            linenumber = fsitem.linenumber;
.LINE 1325

	LEA	IY,IX+%FFFFFF80
	LD	BC,(IY+%FFFFFFFC)
	CALL	__stoiu
	LD	(_linenumber),HL
; 1326	            filehandle[FILE_CURRENT] = fsitem.fp;
.LINE 1326

	LD	A,(IY+%FFFFFFFE)
	LD	(_filehandle),A
; 1327	            strcpy(filename[FILE_CURRENT], fsitem.filename);
.LINE 1327

	LD	HL,IX
	LD	BC,-129
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	BC,_filename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
; 1328	        }
; 1329	        else incfiles = false;
.LINE 1329

	JR	L_651
L_648:
	LD	(IX+%FFFFFFFF),%0
; 1330	    }
; 1331	    while(incfiles);
L_651:
.LINE 1331

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	NZ,L_645
; 1332	    writeLocalLabels();
.LINE 1332

	CALL	_writeLocalLabels
; 1333	    if(global_errors) return false;
.LINE 1333

	LD	HL,(_global_errors)
	CALL	__scmpzero
	JR	Z,L_654
	XOR	A,A
	JR	L_664
L_654:
; 1334	
; 1335	    printf("%d lines\n\r", linenumber);
.LINE 1335

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,(_linenumber)
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,L__292
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
; 1336	    printf("%d labels\n\r", getGlobalLabelCount());
.LINE 1336

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	CALL	_getGlobalLabelCount
	LD	BC,HL
	CALL	__stoiu
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,L__293
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
; 1337	
; 1338	    // Pass 2
; 1339	    printf("Pass 2...\n\r");
.LINE 1339

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__294
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
; 1340	    //rewind(filehandle[FILE_INPUT]);
; 1341	    reOpenFile(FILE_INPUT, fa_read);
.LINE 1341

	LD	BC,1
	PUSH	BC
	PUSH	BC
	CALL	_reOpenFile
	POP	BC
	POP	BC
; 1342	    //rewind(filehandle[FILE_LOCAL_LABELS]);
; 1343	    reOpenFile(FILE_LOCAL_LABELS, fa_read);
.LINE 1343

	LD	BC,1
	PUSH	BC
	LD	BC,3
	PUSH	BC
	CALL	_reOpenFile
	POP	BC
	POP	BC
; 1344	    //rewind(filehandle[FILE_ANONYMOUS_LABELS]);
; 1345	    reOpenFile(FILE_ANONYMOUS_LABELS, fa_read);
.LINE 1345

	LD	BC,1
	PUSH	BC
	LD	BC,4
	PUSH	BC
	CALL	_reOpenFile
	POP	BC
	POP	BC
; 1346	    passInitialize(2);
.LINE 1346

	LD	BC,2
	PUSH	BC
	CALL	_passInitialize
	POP	BC
; 1347	    listInit(consolelist_enabled);
.LINE 1347

	LD	A,(_consolelist_enabled)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_listInit
	POP	BC
; 1348	    readLocalLabels();
.LINE 1348

	CALL	_readLocalLabels
; 1349	    readAnonymousLabel();
.LINE 1349

	CALL	_readAnonymousLabel
; 1350	    do {
; 1351	        while (agon_fgets(line, sizeof(line), FILE_CURRENT)){
.LINE 1351

	JR	L_656
L_657:
; 1352	            linenumber++;
.LINE 1352

	LD	BC,(_linenumber)
	INC	BC
	LD	(_linenumber),BC
; 1353	            listStartLine(line);
.LINE 1353

	LD	HL,IX
	LD	BC,-260
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_listStartLine
	POP	BC
; 1354	            parseLine(line);
.LINE 1354

	LD	HL,IX
	LD	BC,-260
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_parseLine
	POP	BC
; 1355	            refreshlocalLabels();
.LINE 1355

	CALL	_refreshlocalLabels
; 1356	            processInstructions();
.LINE 1356

	CALL	_processInstructions
; 1357	            listEndLine(consolelist_enabled);
.LINE 1357

	LD	A,(_consolelist_enabled)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_listEndLine
	POP	BC
; 1358	            processDelayedLineNumberReset();
.LINE 1358

	CALL	_processDelayedLineNumberReset
; 1359	
; 1360	            //printLocalLabelTable();
; 1361	        }
L_656:
.LINE 1361

	LD	BC,0
	PUSH	BC
	LD	BC,128
	PUSH	BC
	LD	HL,IX
	LD	BC,-260
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_agon_fgets
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_657
; 1362	        if(filestackCount()) {
.LINE 1362

	CALL	_filestackCount
	OR	A,A
	JR	Z,L_659
; 1363	            mos_fclose(filehandle[FILE_CURRENT]);
.LINE 1363

	LD	A,(_filehandle)
	LD	C,A
	LD	B,%0
	PUSH	BC
	CALL	_mos_fclose
	POP	BC
; 1364	            incfiles = filestackPop(&fsitem);
.LINE 1364

	LD	HL,IX
	LD	BC,-132
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	CALL	_filestackPop
	POP	BC
	LD	(IX+%FFFFFFFF),A
; 1365	            linenumber = fsitem.linenumber;
.LINE 1365

	LEA	IY,IX+%FFFFFF80
	LD	BC,(IY+%FFFFFFFC)
	CALL	__stoiu
	LD	(_linenumber),HL
; 1366	            filehandle[FILE_CURRENT] = fsitem.fp;
.LINE 1366

	LD	A,(IY+%FFFFFFFE)
	LD	(_filehandle),A
; 1367	            strcpy(filename[FILE_CURRENT], fsitem.filename);
.LINE 1367

	LD	HL,IX
	LD	BC,-129
	ADD	HL,BC
	LD	BC,HL
	PUSH	BC
	LD	BC,_filename
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
; 1368	        }
; 1369	        else incfiles = false;
.LINE 1369

	JR	L_662
L_659:
	LD	(IX+%FFFFFFFF),%0
; 1370	    }
; 1371	    while(incfiles);
L_662:
.LINE 1371

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	NZ,L_656
; 1372	    return true;
.LINE 1372

	LD	A,%1
; 1373	}
L_664:
.LINE 1373

	LD	SP,IX
	POP	IX
	RET	


;**************************** _assemble ***************************
;Name                         Addr/Register   Size   Type
;_listEndLine                        IMPORT  -----   function
;_listStartLine                      IMPORT  -----   function
;_readAnonymousLabel                 IMPORT  -----   function
;_readLocalLabels                    IMPORT  -----   function
;_consolelist_enabled                IMPORT      1   variable
;_listInit                           IMPORT  -----   function
;_reOpenFile                         IMPORT  -----   function
;_getGlobalLabelCount                IMPORT  -----   function
;__u_itoa                            IMPORT  -----   function
;_writeLocalLabels                   IMPORT  -----   function
;_filestackPop                       IMPORT  -----   function
;_mos_fclose                         IMPORT  -----   function
;_filestackCount                     IMPORT  -----   function
;_agon_fgets                         IMPORT  -----   function
;_linenumber                         IMPORT      3   variable
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;_filename                           IMPORT    768   variable
;_strcpy                             IMPORT  -----   function
;_filehandle                         IMPORT      6   variable
;_global_errors                      IMPORT      2   variable
;line                                IX-260    128   variable
;fsitem                              IX-132    131   variable
;incfiles                              IX-1      1   variable


; Stack Frame Size: 266 (bytes)
;       Spill Code: -1 (instruction)


.ENDFUNC "assemble",1373,"_assemble"
	SEGMENT STRSECT
L__287:
	DB	"Pass 1..."
	DB	10,13,0
L__292:
	DB	" lines"
	DB	10,13,0
L__293:
	DB	" labels"
	DB	10,13,0
L__294:
	DB	"Pass 2..."
	DB	10,13,0
	XREF _mos_fclose:ROM
	XREF _mos_fopen:ROM
	XREF _filestackPop:ROM
	XREF _filestackPush:ROM
	XREF _filestackCount:ROM
	XREF _filestackInit:ROM
	XREF _listEmit8bit:ROM
	XREF _listEndLine:ROM
	XREF _listStartLine:ROM
	XREF _listInit:ROM
	XREF _err_str2num:ROM
	XREF _str2num:ROM
	XREF _strcasecmp:ROM
	XREF _agon_fwrite:ROM
	XREF _agon_fgets:ROM
	XREF _reOpenFile:ROM
	XREF _getOperatorToken:ROM
	XREF _getLineToken:ROM
	XREF _split_suffix:ROM
	XREF _notEmpty:ROM
	XREF _isEmpty:ROM
	XREF _error:ROM
	XREF _message:ROM
	XREF _output:ROM
	XREF _operand2:ROM
	XREF _operand1:ROM
	XREF _currentline:ROM
	XREF _adlmode:ROM
	XREF _global_errors:ROM
	XREF _totalsize:ROM
	XREF _address:ROM
	XREF _pass:ROM
	XREF _linenumber:ROM
	XREF _filehandle:ROM
	XREF _filename:ROM
	XREF _lineNumberNeedsReset:ROM
	XREF _consolelist_enabled:ROM
	XREF _getGlobalLabelCount:ROM
	XREF _readAnonymousLabel:ROM
	XREF _writeAnonymousLabel:ROM
	XREF _readLocalLabels:ROM
	XREF _writeLocalLabels:ROM
	XREF _clearLocalLabels:ROM
	XREF _insertLocalLabel:ROM
	XREF _insertGlobalLabel:ROM
	XREF _findLabel:ROM
	XREF _permittype_matchlist:ROM
	XREF _instruction_table_lookup:ROM
	XREF _tolower:ROM
	XREF _isspace:ROM
	XREF _isdigit:ROM
	XREF _strlen:ROM
	XREF _strcmp:ROM
	XREF _strcpy:ROM
	XREF __u_itoa:ROM
	XREF ___print_sendstring:ROM
	XREF ___print_xputch:ROM
	XREF ___print_uputch:ROM
	XREF __indcall:ROM
	XREF __lcmps:ROM
	XREF __lcmpu:ROM
	XREF __ladd:ROM
	XREF __lsub:ROM
	XREF __sneg:ROM
	XREF __lnot:ROM
	XREF __land:ROM
	XREF __lshl:ROM
	XREF __lshrs:ROM
	XREF __lshru:ROM
	XREF __stoiu:ROM
	XREF __itol:ROM
	XREF __ildix:ROM
	XREF __istix:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __lcmpzero:ROM
	XREF __case8D:ROM
	XREF __seqcaseD:ROM
	XREF __ladd_b:ROM
	XREF __ishrs_b:ROM
	XDEF _assemble
	XDEF _processDelayedLineNumberReset
	XDEF _passInitialize
	XDEF _processInstructions
	XDEF _handle_assembler_command
	XDEF _handle_asm_align
	XDEF _handle_asm_blk
	XDEF _handle_asm_include
	XDEF _handle_asm_org
	XDEF _handle_asm_adl
	XDEF _handle_asm_equ
	XDEF _handle_asm_dw
	XDEF _handle_asm_db
	XDEF _parse_asm_keyval_pair
	XDEF _parse_asm_single_immediate
	XDEF _emit_quotedstring
	XDEF _get_escaped_char
	XDEF _emit_32bit
	XDEF _emit_24bit
	XDEF _emit_16bit
	XDEF _emit_8bit
	XDEF _emit_instruction
	XDEF _transform_instruction
	XDEF _prefix_ddfd_suffix
	XDEF _get_ddfd_prefix
	XDEF _emit_adlsuffix_code
	XDEF _emit_immediate
	XDEF _get_immediate_size
	XDEF _adl_action
	XDEF _getADLsuffix
	XDEF _refreshlocalLabels
	XDEF _definelabel
	XDEF _parseLine
	XDEF _parse_operand
	XDEF _getLabelValue
	XDEF _getAsciiValue
	XDEF _advanceLocalLabel
	XDEF _empty_operand
	END
