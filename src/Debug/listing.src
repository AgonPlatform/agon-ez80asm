; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optsize -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\listing.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",16
.DEFINE "reg"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "reg_index"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "indirect"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "cc"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "cc_index"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "displacement"
.VALUE 7
.CLASS 8
.TYPE 3
.ENDEF
.DEFINE "displacement_provided"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "immediate_provided"
.VALUE 10
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "immediate"
.VALUE 11
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "wasLabel"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",4
.DEFINE "suffix"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "prefix1"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "prefix2"
.VALUE 2
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "opcode"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",16
.DEFINE "operandA"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "operandB"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "ddfdpermitted"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "transformA"
.VALUE 7
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "transformB"
.VALUE 10
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "prefix"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "opcode"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "adl"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",17
.DEFINE "name"
.VALUE 0
.CLASS 8
.DIM 8
.TYPE 98
.ENDEF
.DEFINE "type"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "asmtype"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "listnumber"
.VALUE 10
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "list"
.VALUE 11
.CLASS 8
.TAG "NONAME2"
.TYPE 40
.ENDEF
.DEFINE "asmargument"
.VALUE 14
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME3"
.BEGREC "NONAME4",6
.DEFINE "type"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "match"
.VALUE 3
.CLASS 8
.TYPE 556
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",264
.DEFINE "current_instruction"
.VALUE 0
.CLASS 8
.TAG "NONAME3"
.TYPE 40
.ENDEF
.DEFINE "next"
.VALUE 3
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "label"
.VALUE 6
.CLASS 8
.DIM 32
.TYPE 98
.ENDEF
.DEFINE "mnemonic"
.VALUE 38
.CLASS 8
.DIM 16
.TYPE 98
.ENDEF
.DEFINE "suffix"
.VALUE 54
.CLASS 8
.DIM 16
.TYPE 98
.ENDEF
.DEFINE "operand1"
.VALUE 70
.CLASS 8
.DIM 32
.TYPE 98
.ENDEF
.DEFINE "operand2"
.VALUE 102
.CLASS 8
.DIM 32
.TYPE 98
.ENDEF
.DEFINE "comment"
.VALUE 134
.CLASS 8
.DIM 128
.TYPE 98
.ENDEF
.DEFINE "size"
.VALUE 262
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",261
.DEFINE "start"
.VALUE 0
.CLASS 8
.DIM 256
.TYPE 98
.ENDEF
.DEFINE "length"
.VALUE 256
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "next"
.VALUE 257
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "terminator"
.VALUE 260
.CLASS 8
.TYPE 2
.ENDEF
.ENDREC "NONAME6"
	SEGMENT BSS
__listLine:
	DS	256
.DEFINE "_listLine"
.ALIAS "__listLine"
.CLASS 83
.VALUE __listLine
.DIM 256
.TYPE 98
.ENDEF
__listAddress:
	DS	4*1
.DEFINE "_listAddress"
.ALIAS "__listAddress"
.CLASS 83
.VALUE __listAddress
.TYPE 15
.ENDEF
__listObjects:
	DS	256
.DEFINE "_listObjects"
.ALIAS "__listObjects"
.CLASS 83
.VALUE __listObjects
.DIM 256
.TYPE 108
.ENDEF
__listObjectCount:
	DS	1
.DEFINE "_listObjectCount"
.ALIAS "__listObjectCount"
.CLASS 83
.VALUE __listObjectCount
.TYPE 12
.ENDEF
	SEGMENT DATA
__listFirstline:
	DB	1
.DEFINE "_listFirstline"
.ALIAS "__listFirstline"
.CLASS 69
.VALUE __listFirstline
.TYPE 12
.ENDEF
__listHeader:
	DB	80
	DB	67
	DB	32
	DB	32
	DB	32
	DB	32
	DB	32
	DB	32
	DB	79
	DB	117
	DB	116
	DB	112
	DB	117
	DB	116
	DB	32
	DB	32
	DB	32
	DB	32
	DB	32
	DB	32
	DB	32
	DB	32
	DB	32
	DB	32
	DB	32
	DB	32
	DB	76
	DB	105
	DB	110
	DB	101
	DB	32
	DB	32
	DB	32
	DB	83
	DB	111
	DB	117
	DB	114
	DB	99
	DB	101
	DB	10
	DB	0
.DEFINE "_listHeader"
.ALIAS "__listHeader"
.CLASS 69
.VALUE __listHeader
.DIM 41
.TYPE 98
.ENDEF
	SEGMENT BSS
_buffer:
	DS	320
.DEFINE "buffer"
.ALIAS "_buffer"
.CLASS 83
.VALUE _buffer
.DIM 320
.TYPE 98
.ENDEF
;    1	#include <stdio.h>
;    2	#include <string.h>
;    3	#include "listing.h"
;    4	#include "globals.h"
;    5	#include "utils.h"
;    6	#include "stdint.h"
;    7	
;    8	char _listLine[LINEMAX];
;    9	uint32_t _listAddress;
;   10	uint8_t _listObjects[256];
;   11	uint8_t _listObjectCount;
;   12	bool _listFirstline = true;
;   13	
;   14	char _listHeader[] = "PC      Output            Line   Source\n";
;   15	
;   16	char buffer[LINEMAX + 64];
	SEGMENT CODE
;   17	
;   18	void listInit(bool console) {
_listInit:
.DEFINE "_listInit"

.VALUE _listInit

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "listInit",18,"_listInit"

.LINE 18

.DEFINE "console"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   19	    sprintf(buffer, "%s", _listHeader);
.LINE 19

	LD	BC,_buffer
	LD	(___print_out),BC
	LD	BC,___print_sputch
	LD	(___print_xputch),BC
	LD	BC,__listHeader
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	___print_sputch
	POP	BC
;   20	    agon_fputs(buffer, FILE_LISTING);
.LINE 20

	LD	BC,5
	PUSH	BC
	LD	BC,_buffer
	PUSH	BC
	CALL	_agon_fputs
	POP	BC
	POP	BC
;   21	    if(console) printf("%s", _listHeader);
.LINE 21

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_1
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,__listHeader
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
L_1:
;   22	    _listFirstline = false;
.LINE 22

	XOR	A,A
	LD	(__listFirstline),A
;   23	    _listLine[0] = 0;
.LINE 23

	XOR	A,A
	LD	(__listLine),A
;   24	    _listObjectCount = 0;
.LINE 24

	XOR	A,A
	LD	(__listObjectCount),A
;   25	}
.LINE 25

	LD	SP,IX
	POP	IX
	RET	


;**************************** _listInit ***************************
;Name                         Addr/Register   Size   Type
;__listObjectCount                   STATIC      1   variable
;__listLine                          STATIC    256   variable
;__listFirstline                     STATIC      1   variable
;___print_uputch                     IMPORT  -----   function
;_agon_fputs                         IMPORT  -----   function
;__listHeader                        STATIC     41   variable
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_sputch                     IMPORT  -----   function
;___print_out                        IMPORT      3   variable
;_buffer                             STATIC    320   variable
;console                               IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "listInit",25,"_listInit"
;   26	
;   27	void listStartLine(char *line) {
_listStartLine:
.DEFINE "_listStartLine"

.VALUE _listStartLine

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "listStartLine",27,"_listStartLine"

.LINE 27

.DEFINE "line"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   28	    strcpy(_listLine, line);
.LINE 28

	LD	BC,(IX+%6)
	PUSH	BC
	LD	BC,__listLine
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;   29	    trimRight(_listLine);
.LINE 29

	LD	BC,__listLine
	PUSH	BC
	CALL	_trimRight
	POP	BC
;   30	    _listAddress = address;
.LINE 30

	LD	BC,(_address)
	LD	A,(_address+3)
	LD	(__listAddress),BC
	LD	(__listAddress+3),A
;   31	    _listObjectCount = 0;
.LINE 31

	XOR	A,A
	LD	(__listObjectCount),A
;   32	}
.LINE 32

	LD	SP,IX
	POP	IX
	RET	


;**************************** _listStartLine ***************************
;Name                         Addr/Register   Size   Type
;__listObjectCount                   STATIC      1   variable
;__listAddress                       STATIC      4   variable
;_address                            IMPORT      4   variable
;_trimRight                          IMPORT  -----   function
;__listLine                          STATIC    256   variable
;_strcpy                             IMPORT  -----   function
;line                                  IX+6      3   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "listStartLine",32,"_listStartLine"
;   33	
;   34	void listEndLine(bool console) {
_listEndLine:
.DEFINE "_listEndLine"

.VALUE _listEndLine

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "listEndLine",34,"_listEndLine"

.LINE 34

.DEFINE "console"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

.DEFINE "lines"

.CLASS 65

.VALUE -1

.TYPE 12

.ENDEF

.DEFINE "linemax"

.CLASS 65

.VALUE -2

.TYPE 12

.ENDEF

.DEFINE "objectnum"

.CLASS 65

.VALUE -3

.TYPE 12

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -4

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;   35	    uint8_t i, lines, objectnum;
;   36	    uint8_t linemax;
;   37	
;   38	    linemax = (_listObjectCount / OBJECTS_PER_LINE);
.LINE 38

	LD	A,(__listObjectCount)
	UEXT	HL
	LD	L,A
	LD	BC,6
	CALL	__idivs
	LD	(IX+%FFFFFFFE),L
;   39	    if(_listObjectCount % OBJECTS_PER_LINE) linemax ++;
.LINE 39

	LD	A,(__listObjectCount)
	UEXT	HL
	LD	L,A
	LD	BC,6
	CALL	__irems
	CALL	__icmpzero
	JR	Z,L_7
	INC	(IX+%FFFFFFFE)
L_7:
;   40	    if(linemax == 0) linemax = 1;
.LINE 40

	LD	A,(IX+%FFFFFFFE)
	OR	A,A
	JR	NZ,L_8
	LD	(IX+%FFFFFFFE),%1
L_8:
;   41	
;   42	    objectnum = 0;
.LINE 42

	LD	(IX+%FFFFFFFD),%0
;   43	    for(lines = 0; lines < linemax; lines++) {
.LINE 43

	LD	(IX+%FFFFFFFF),%0
	JR	L_32
L_30:
;   44	        if(lines == 0) {
.LINE 44

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	NZ,L_13
;   45	            sprintf(buffer, "%06X  ",_listAddress);
.LINE 45

	LD	BC,_buffer
	LD	(___print_out),BC
	LD	BC,___print_sputch
	LD	(___print_xputch),BC
	LD	A,%6
	LD	(___print_fmt+5),A
	LD	A,%60
	LD	(___print_fmt+1),A
	LD	A,%78
	LD	(___print_fmt+4),A
	LD	A,(__listAddress+3)
	LD	C,A
	LD	B,%0
	PUSH	BC
	LD	BC,(__listAddress)
	PUSH	BC
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__6
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	___print_sputch
	POP	BC
;   46	            agon_fputs(buffer, FILE_LISTING);
.LINE 46

	LD	BC,5
	PUSH	BC
	LD	BC,_buffer
	PUSH	BC
	CALL	_agon_fputs
	POP	BC
	POP	BC
;   47	            if(console) printf("%s",buffer);
.LINE 47

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_24
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,_buffer
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   48	        }
;   49	        else {
.LINE 49

	JR	L_24
L_13:
;   50	            sprintf(buffer, "        ");
.LINE 50

	LD	BC,_buffer
	LD	(___print_out),BC
	LD	BC,___print_sputch
	LD	(___print_xputch),BC
	LD	BC,L__8
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	___print_sputch
	POP	BC
;   51	            agon_fputs(buffer, FILE_LISTING);
.LINE 51

	LD	BC,5
	PUSH	BC
	LD	BC,_buffer
	PUSH	BC
	CALL	_agon_fputs
	POP	BC
	POP	BC
;   52	            if(console) printf("%s",buffer);
.LINE 52

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_24
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,_buffer
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   53	        }
L_24:
.LINE 53

;   54	        for(i = 0; i < OBJECTS_PER_LINE; i++) {
.LINE 54

	LD	(IX+%FFFFFFFC),%0
	JR	L_23
L_21:
;   55	            if(objectnum < _listObjectCount) {
.LINE 55

	LD	A,(IX+%FFFFFFFD)
	LD	HL,__listObjectCount
	CP	A,(HL)
	JR	NC,L_20
;   56	                sprintf(buffer, "%02X ",_listObjects[objectnum]);
.LINE 56

	LD	BC,_buffer
	LD	(___print_out),BC
	LD	BC,___print_sputch
	LD	(___print_xputch),BC
	LD	A,%2
	LD	(___print_fmt+5),A
	LD	A,%60
	LD	(___print_fmt+1),A
	LD	A,%78
	LD	(___print_fmt+4),A
	LD	A,(IX+%FFFFFFFD)
	UEXT	HL
	LD	L,A
	LD	BC,__listObjects
	ADD	HL,BC
	LD	A,(HL)
	UEXT	HL
	LD	L,A
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,32
	PUSH	BC
	CALL	___print_sputch
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	___print_sputch
	POP	BC
;   57	                agon_fputs(buffer, FILE_LISTING);
.LINE 57

	LD	BC,5
	PUSH	BC
	LD	BC,_buffer
	PUSH	BC
	CALL	_agon_fputs
	POP	BC
	POP	BC
;   58	                if(console) printf("%s",buffer);
.LINE 58

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_17
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,_buffer
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
L_17:
;   59	                objectnum++;
.LINE 59

	INC	(IX+%FFFFFFFD)
;   60	            }
;   61	            else {
.LINE 61

	JR	L_22
L_20:
;   62	                sprintf(buffer, "   ");
.LINE 62

	LD	BC,_buffer
	LD	(___print_out),BC
	LD	BC,___print_sputch
	LD	(___print_xputch),BC
	LD	BC,L__12
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	___print_sputch
	POP	BC
;   63	                agon_fputs(buffer, FILE_LISTING);
.LINE 63

	LD	BC,5
	PUSH	BC
	LD	BC,_buffer
	PUSH	BC
	CALL	_agon_fputs
	POP	BC
	POP	BC
;   64	                if(console) printf("%s",buffer);
.LINE 64

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_22
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,_buffer
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   65	            }
;   66	        }
L_22:
.LINE 66

	INC	(IX+%FFFFFFFC)
L_23:
	LD	A,(IX+%FFFFFFFC)
	CP	A,%6
	JR	C,L_21
;   67	        if(lines == 0) {
.LINE 67

	LD	A,(IX+%FFFFFFFF)
	OR	A,A
	JR	NZ,L_28
;   68	            sprintf(buffer, "%04d   %s\n",linenumber, _listLine);
.LINE 68

	LD	BC,_buffer
	LD	(___print_out),BC
	LD	BC,___print_sputch
	LD	(___print_xputch),BC
	LD	A,%4
	LD	(___print_fmt+5),A
	LD	A,%40
	LD	(___print_fmt+1),A
	LD	BC,(_linenumber)
	XOR	A,A
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,L__16
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,__listLine
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,10
	PUSH	BC
	CALL	___print_sputch
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	___print_sputch
	POP	BC
;   69	            agon_fputs(buffer, FILE_LISTING);
.LINE 69

	LD	BC,5
	PUSH	BC
	LD	BC,_buffer
	PUSH	BC
	CALL	_agon_fputs
	POP	BC
	POP	BC
;   70	            if(console) printf("%s",buffer);
.LINE 70

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_31
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,_buffer
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   71	        }
;   72	        else {
.LINE 72

	JR	L_31
L_28:
;   73	            sprintf(buffer, "\n");
.LINE 73

	LD	BC,_buffer
	LD	(___print_out),BC
	LD	BC,___print_sputch
	LD	(___print_xputch),BC
	LD	BC,10
	PUSH	BC
	CALL	___print_sputch
	POP	BC
	LD	BC,0
	PUSH	BC
	CALL	___print_sputch
	POP	BC
;   74	            agon_fputs(buffer, FILE_LISTING);
.LINE 74

	LD	BC,5
	PUSH	BC
	LD	BC,_buffer
	PUSH	BC
	CALL	_agon_fputs
	POP	BC
	POP	BC
;   75	            if(console) printf("%s",buffer);
.LINE 75

	LD	A,(IX+%6)
	OR	A,A
	JR	Z,L_31
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,_buffer
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   76	        }
;   77	    }
L_31:
.LINE 77

	INC	(IX+%FFFFFFFF)
L_32:
	LD	A,(IX+%FFFFFFFF)
	CP	A,(IX+%FFFFFFFE)
	JR	C,L_30
;   78	}
.LINE 78

	LD	SP,IX
	POP	IX
	RET	


;**************************** _listEndLine ***************************
;Name                         Addr/Register   Size   Type
;__listLine                          STATIC    256   variable
;_linenumber                         IMPORT      3   variable
;__u_itoa                            IMPORT  -----   function
;__listObjects                       STATIC    256   variable
;___print_uputch                     IMPORT  -----   function
;_agon_fputs                         IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;__listAddress                       STATIC      4   variable
;__u_uitoa                           IMPORT  -----   function
;___print_fmt                        IMPORT     19   variable
;___print_xputch                     IMPORT      3   variable
;___print_sputch                     IMPORT  -----   function
;___print_out                        IMPORT      3   variable
;_buffer                             STATIC    320   variable
;__listObjectCount                   STATIC      1   variable
;i                                     IX-4      1   variable
;objectnum                             IX-3      1   variable
;linemax                               IX-2      1   variable
;lines                                 IX-1      1   variable
;console                               IX+6      1   parameter


; Stack Frame Size: 13 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "listEndLine",78,"_listEndLine"
	SEGMENT STRSECT
L__6:
	DB	"  "
	DB	0
L__8:
	DB	"        "
	DB	0
L__12:
	DB	"   "
	DB	0
L__16:
	DB	"   "
	DB	0
	SEGMENT CODE
;   79	
;   80	void listEmit8bit(uint8_t value) {
_listEmit8bit:
.DEFINE "_listEmit8bit"

.VALUE _listEmit8bit

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "listEmit8bit",80,"_listEmit8bit"

.LINE 80

.DEFINE "value"

.CLASS 65

.VALUE 6

.TYPE 12

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   81	    _listObjects[_listObjectCount++] = value; 
.LINE 81

	LD	A,(__listObjectCount)
	UEXT	HL
	LD	L,A
	LD	BC,__listObjects
	ADD	HL,BC
	LD	A,(IX+%6)
	LD	(HL),A
	LD	A,(__listObjectCount)
	INC	A
	LD	(__listObjectCount),A
.LINE 82

	LD	SP,IX
	POP	IX
	RET	


;**************************** _listEmit8bit ***************************
;Name                         Addr/Register   Size   Type
;__listObjectCount                   STATIC      1   variable
;__listObjects                       STATIC    256   variable
;value                                 IX+6      1   parameter


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "listEmit8bit",82,"_listEmit8bit"
	XREF _agon_fputs:ROM
	XREF _trimRight:ROM
	XREF _address:ROM
	XREF _linenumber:ROM
	XREF _strcpy:ROM
	XREF __u_uitoa:ROM
	XREF __u_itoa:ROM
	XREF ___print_sendstring:ROM
	XREF ___print_xputch:ROM
	XREF ___print_sputch:ROM
	XREF ___print_uputch:ROM
	XREF ___print_out:ROM
	XREF ___print_fmt:ROM
	XREF __idivs:ROM
	XREF __irems:ROM
	XREF __itol:ROM
	XREF __icmpzero:ROM
	XDEF _listEmit8bit
	XDEF _listEndLine
	XDEF _listStartLine
	XDEF _listInit
	XDEF _buffer
	XDEF __listHeader
	XDEF __listFirstline
	XDEF __listObjectCount
	XDEF __listObjects
	XDEF __listAddress
	XDEF __listLine
	END
