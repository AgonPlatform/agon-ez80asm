Zilog eZ80 Macro Assembler Version 4.3 (19073001) RELISTED01-Mar-23     16:29:18     page:   1


PC     Object              I  Line    Source 
                           A     1    ;
                           A     2    ; Title:	Hello World - Initialisation Code
                           A     3    ; Author:	Dean Belfield
                           A     4    ; Created:	22/11/2022
                           A     5    ; Last Updated: 25/11/2022
                           A     6    ;
                           A     7    ; Modinfo:
                           A     8    ; 25/11/2022:	Added parameter parsing; now ac
                           A     9    
                           A    10    			SEGMENT CODE
                           A    11    			
                           A    12    			XREF	__low_bss
                           A    13    			XREF	__len_bss
                           A    14    			
                           A    15    			XREF	_main
                           A    16    			
                           A    17    			.ASSUME	ADL = 1	
                           A    18    
       00000010            A    19    argv_ptrs_max:		EQU	16			; Maximum n
                           A    20    
                           A    21    ;
                           A    22    ; Start in ADL mode
                           A    23    ;
                           A    24    
040000 C3 45 00 04         A    25    			JP	_start			; Jump to start
                           A    26    
                           A    27    ;
                           A    28    ; The header stuff
                           A    29    ;
040004 455A3830 41534D2E   A    30    _exec_name:		DB	"EZ80ASM.BIN", 0		; T
04000C 42494E00 
                           A    31    
                           A    32    			ALIGN	64			; The executabl
                           A    33    			
040040 4D4F53              A    34    			DB	"MOS"			; Flag for MOS 
040043 00                  A    35    			DB	00h			; MOS header versio
040044 01                  A    36    			DB	01h			; Flag for run mode
                           A    37    
                           A    38    ;
                           A    39    ; And the code follows on immediately after the
                           A    40    ;
040045 F5                  A    41    _start:			PUSH	AF			; Preserve 
040046 C5                  A    42    			PUSH	BC
040047 D5                  A    43    			PUSH	DE
040048 DDE5                A    44    			PUSH	IX
04004A FDE5                A    45    			PUSH	IY			; Need to prese
                           A    46    ;			
04004C E5                  A    47    			PUSH	HL			; Clear the RAM
04004D CD 6E 00 04         A    48    			CALL	_clear_bss
040051 E1                  A    49    			POP	HL
                           A    50    ;
040052 DD21 F7 66 04       A    51    			LD	IX, argv_ptrs		; The argv 
040057 DDE5                A    52    			PUSH	IX			; Parameter 2: 
040059 CD 8D 00 04         A    53    			CALL	_parse_params		; Parse
04005D 0600                A    54    			LD	B, 0			; Clear B from 
04005F C5                  A    55    			PUSH	BC			; Parameter 1: 
040060 CD DC 00 04         A    56    			CALL	_main			; int main(
040064 D1                  A    57    			POP	DE			; Balance the stack
040065 D1                  A    58    			POP	DE
                           A    59    
040066 FDE1                A    60    			POP	IY			; Restore registers
040068 DDE1                A    61    			POP	IX
04006A D1                  A    62    			POP	DE
04006B C1                  A    63    			POP 	BC
04006C F1                  A    64    			POP	AF
04006D C9                  A    65    			RET
                           A    66    			
                           A    67    ; Clear the memory
                           A    68    ;
04006E 01 F8 77 02         A    69    _clear_bss:		LD	BC, __len_bss		; Check
040072 3E 02               A    70    			LD	a, __len_bss >> 16
040074 B1                  A    71    			OR	A, C
040075 B0                  A    72    			OR	A, B
040076 C8                  A    73    			RET	Z			; BSS is zero-lengt
040077 AF                  A    74    			XOR	A, A
040078 32 B9 87 04         A    75    			LD 	(__low_bss), A
04007C ED62                A    76    			SBC	HL, HL			; HL = 0
04007E 0B                  A    77    			DEC	BC			; 1st byte's taken 
04007F ED42                A    78    			SBC	HL, BC
040081 C8                  A    79    			RET	Z		  	; Just 1 byte ...
040082 21 B9 87 04         A    80    			LD	HL, __low_bss		; Reset HL
040086 11 BA 87 04         A    81    			LD	DE, __low_bss + 1	; [DE] = bs
04008A EDB0                A    82    			LDIR				; Clear this se
04008C C9                  A    83    			RET
                           A    84    			
                           A    85    ; Parse the parameter string into a C array
                           A    86    ; Parameters
                           A    87    ; - HL: Address of parameter string
                           A    88    ; - IX: Address for array pointer storage
                           A    89    ; Returns:
                           A    90    ; -  C: Number of parameters parsed
                           A    91    ;
04008D 01 04 00 04         A    92    _parse_params:		LD	BC, _exec_name
040091 DD0F00              A    93    			LD	(IX+0), BC		; ARGV[0] = the
040094 DD23                A    94    			INC	IX
040096 DD23                A    95    			INC	IX
040098 DD23                A    96    			INC	IX
04009A CD D5 00 04         A    97    			CALL	_skip_spaces		; Skip 
                           A    98    ;
04009E 01010000            A    99    			LD	BC, 1			; C: ARGC = 1 -
0400A2 060F                A   100    			LD	B, argv_ptrs_max - 1	; B: Ma
                           A   101    ;
0400A4                     A   102    _parse_params_1:	
0400A4 C5                  A   103    			PUSH	BC			; Stack ARGC	
0400A5 E5                  A   104    			PUSH	HL			; Stack start a
0400A6 CD C6 00 04         A   105    			CALL	_get_token		; Get the n
0400AA 79                  A   106    			LD	A, C			; A: Length of 
0400AB D1                  A   107    			POP	DE			; Start address of 
0400AC C1                  A   108    			POP	BC			; ARGC
0400AD B7                  A   109    			OR	A			; Check for A=0 (no
0400AE C8                  A   110    			RET	Z
                           A   111    ;
0400AF DD1F00              A   112    			LD	(IX+0), DE		; Store the poi
0400B2 E5                  A   113    			PUSH	HL			; DE=HL
0400B3 D1                  A   114    			POP	DE
0400B4 CD D5 00 04         A   115    			CALL	_skip_spaces		; And s
0400B8 AF                  A   116    			XOR	A
0400B9 12                  A   117    			LD	(DE), A			; Zero-terminat
0400BA DD23                A   118    			INC	IX
0400BC DD23                A   119    			INC	IX
0400BE DD23                A   120    			INC	IX			; Advance to next p
0400C0 0C                  A   121    			INC	C			; Increment ARGC
0400C1 79                  A   122    			LD	A, C			; Check for C >
0400C2 B8                  A   123    			CP	B
0400C3 38 DF               A   124    			JR	C, _parse_params_1	; And loop
0400C5 C9                  A   125    			RET
                           A   126    
                           A   127    ; Get the next token
                           A   128    ; Parameters:
                           A   129    ; - HL: Address of parameter string
                           A   130    ; Returns:
                           A   131    ; - HL: Address of first character after token
                           A   132    ; -  C: Length of token (in characters)
                           A   133    ;
0400C6 0E00                A   134    _get_token:		LD	C, 0			; Initialis
0400C8 7E                  A   135    $$:			LD	A, (HL)			; Get the chara
0400C9 B7                  A   136    			OR	A			; Exit if 0 (end of
0400CA C8                  A   137    			RET 	Z
0400CB FE0D                A   138    			CP	13			; Exit if CR (end o
0400CD C8                  A   139    			RET	Z
0400CE FE20                A   140    			CP	' '			; Exit if space (en
0400D0 C8                  A   141    			RET	Z
0400D1 23                  A   142    			INC	HL			; Advance to next c
0400D2 0C                  A   143    			INC 	C			; Increment len
0400D3 18 F3               A   144    			JR	$B
                           A   145    	
                           A   146    ; Skip spaces in the parameter string
                           A   147    ; Parameters:
                           A   148    ; - HL: Address of parameter string
                           A   149    ; Returns:
                           A   150    ; - HL: Address of next none-space character
                           A   151    ;    F: Z if at end of string, otherwise NZ if 
                           A   152    ;
0400D5 7E                  A   153    _skip_spaces:		LD	A, (HL)			; Get t
0400D6 FE20                A   154    			CP	' '			; Exit if not space
0400D8 C0                  A   155    			RET	NZ
0400D9 23                  A   156    			INC	HL			; Advance to next c
0400DA 18 F9               A   157    			JR	_skip_spaces		; Increment
                           A   158    
                           A   159    
                           A   160    			SEGMENT DATA
                           A   161    
                           A   162    
                           A   163    ; Storage for the argv array pointers
                           A   164    ;
0466F7 000000 000000       A   165    argv_ptrs:		BLKP	argv_ptrs_max, 0
0466FD 000000 000000 
046703 000000 000000 
046709 000000 000000 
04670F 000000 000000 
046715 000000 000000 
04671B 000000 000000 
046721 000000 000000 
                           A   166    			
                           A   167    			END


Errors: 0
Warnings: 0
Lines Assembled: 168
