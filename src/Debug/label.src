; Zilog eZ80 ANSI C Compiler Release 3.4
; -nomodsect -optsize -noreduceopt -nopadbranch -debug
; -peephole -globalopt -localcse -const=ROM 
	FILE	"..\label.c"
	.assume ADL=1
.DEBUG "C"
	SEGMENT CODE
.BEGREC "fmt_type",19
.DEFINE "status"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "flags"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "size"
.VALUE 2
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "chr"
.VALUE 3
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "type"
.VALUE 4
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "field_width"
.VALUE 5
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "precision"
.VALUE 6
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "set_begin"
.VALUE 7
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "set_end"
.VALUE 10
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "pad_whole"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_pre_fract"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_post_fract"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "pad_at"
.VALUE 16
.CLASS 8
.TYPE 34
.ENDEF
.ENDREC "fmt_type"
.BEGREC "flt_info",12
.DEFINE "flags"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "exp"
.VALUE 1
.CLASS 8
.TYPE 2
.ENDEF
.DEFINE "digits"
.VALUE 2
.CLASS 8
.DIM 10
.TYPE 108
.ENDEF
.ENDREC "flt_info"
.BEGREC "NONAME0",7
.DEFINE "name"
.VALUE 0
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "address"
.VALUE 3
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME0"
.BEGREC "NONAME1",5
.DEFINE "defined"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "address"
.VALUE 1
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME1"
.BEGREC "NONAME2",6
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "rem"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME2"
.BEGREC "NONAME3",8
.DEFINE "quot"
.VALUE 0
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "rem"
.VALUE 4
.CLASS 8
.TYPE 5
.ENDEF
.ENDREC "NONAME3"
.BEGREC "header",6
.DEFINE "s"
.VALUE 0
.CLASS 11
.TAG "NONAME4"
.TYPE 8
.ENDEF
.DEFINE "x"
.VALUE 0
.CLASS 11
.TYPE 2
.ENDEF
.ENDREC "header"
.BEGREC "NONAME4",6
.DEFINE "ptr"
.VALUE 0
.CLASS 8
.TAG "header"
.TYPE 40
.ENDEF
.DEFINE "size"
.VALUE 3
.CLASS 8
.TYPE 14
.ENDEF
.ENDREC "NONAME4"
.BEGREC "NONAME5",133
.DEFINE "start"
.VALUE 0
.CLASS 8
.DIM 128
.TYPE 98
.ENDEF
.DEFINE "length"
.VALUE 128
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "next"
.VALUE 129
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "terminator"
.VALUE 132
.CLASS 8
.TYPE 2
.ENDEF
.ENDREC "NONAME5"
.BEGREC "NONAME6",16
.DEFINE "reg"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "reg_index"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "indirect"
.VALUE 4
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "cc"
.VALUE 5
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "cc_index"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "displacement"
.VALUE 7
.CLASS 8
.TYPE 3
.ENDEF
.DEFINE "displacement_provided"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "immediate_provided"
.VALUE 10
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "immediate"
.VALUE 11
.CLASS 8
.TYPE 5
.ENDEF
.DEFINE "wasLabel"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME6"
.BEGREC "NONAME7",4
.DEFINE "suffix"
.VALUE 0
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "prefix1"
.VALUE 1
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "prefix2"
.VALUE 2
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "opcode"
.VALUE 3
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME7"
.BEGREC "NONAME8",16
.DEFINE "operandA"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "operandB"
.VALUE 3
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "ddfdpermitted"
.VALUE 6
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "transformA"
.VALUE 7
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "transformB"
.VALUE 10
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "prefix"
.VALUE 13
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "opcode"
.VALUE 14
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "adl"
.VALUE 15
.CLASS 8
.TYPE 12
.ENDEF
.ENDREC "NONAME8"
.BEGREC "NONAME9",17
.DEFINE "name"
.VALUE 0
.CLASS 8
.DIM 8
.TYPE 98
.ENDEF
.DEFINE "type"
.VALUE 8
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "asmtype"
.VALUE 9
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "listnumber"
.VALUE 10
.CLASS 8
.TYPE 12
.ENDEF
.DEFINE "list"
.VALUE 11
.CLASS 8
.TAG "NONAME8"
.TYPE 40
.ENDEF
.DEFINE "asmargument"
.VALUE 14
.CLASS 8
.TYPE 4
.ENDEF
.ENDREC "NONAME9"
.BEGREC "NONAME10",6
.DEFINE "type"
.VALUE 0
.CLASS 8
.TYPE 4
.ENDEF
.DEFINE "match"
.VALUE 3
.CLASS 8
.TYPE 556
.ENDEF
.ENDREC "NONAME10"
.BEGREC "NONAME11",264
.DEFINE "current_instruction"
.VALUE 0
.CLASS 8
.TAG "NONAME9"
.TYPE 40
.ENDEF
.DEFINE "next"
.VALUE 3
.CLASS 8
.TYPE 34
.ENDEF
.DEFINE "label"
.VALUE 6
.CLASS 8
.DIM 32
.TYPE 98
.ENDEF
.DEFINE "mnemonic"
.VALUE 38
.CLASS 8
.DIM 16
.TYPE 98
.ENDEF
.DEFINE "suffix"
.VALUE 54
.CLASS 8
.DIM 16
.TYPE 98
.ENDEF
.DEFINE "operand1"
.VALUE 70
.CLASS 8
.DIM 32
.TYPE 98
.ENDEF
.DEFINE "operand2"
.VALUE 102
.CLASS 8
.DIM 32
.TYPE 98
.ENDEF
.DEFINE "comment"
.VALUE 134
.CLASS 8
.DIM 128
.TYPE 98
.ENDEF
.DEFINE "size"
.VALUE 262
.CLASS 8
.TYPE 13
.ENDEF
.ENDREC "NONAME11"
	SEGMENT BSS
_an_prev:
	DS	5
.DEFINE "an_prev"
.ALIAS "_an_prev"
.CLASS 83
.VALUE _an_prev
.TAG "NONAME1"
.TYPE 8
.ENDEF
_an_next:
	DS	5
.DEFINE "an_next"
.ALIAS "_an_next"
.CLASS 83
.VALUE _an_next
.TAG "NONAME1"
.TYPE 8
.ENDEF
_an_return:
	DS	7
.DEFINE "an_return"
.ALIAS "_an_return"
.CLASS 83
.VALUE _an_return
.TAG "NONAME0"
.TYPE 8
.ENDEF
_globalLabelBuffer:
	DS	131072
.DEFINE "globalLabelBuffer"
.ALIAS "_globalLabelBuffer"
.CLASS 83
.VALUE _globalLabelBuffer
.DIM 131072
.TYPE 98
.ENDEF
_localLabelBuffer:
	DS	4096
.DEFINE "localLabelBuffer"
.ALIAS "_localLabelBuffer"
.CLASS 83
.VALUE _localLabelBuffer
.DIM 4096
.TYPE 98
.ENDEF
_globalLabelBufferIndex:
	DS	2*1
.DEFINE "globalLabelBufferIndex"
.ALIAS "_globalLabelBufferIndex"
.CLASS 83
.VALUE _globalLabelBufferIndex
.TYPE 13
.ENDEF
_localLabelBufferIndex:
	DS	2*1
.DEFINE "localLabelBufferIndex"
.ALIAS "_localLabelBufferIndex"
.CLASS 83
.VALUE _localLabelBufferIndex
.TYPE 13
.ENDEF
_globalLabelTable:
	DS	24576
.DEFINE "globalLabelTable"
.ALIAS "_globalLabelTable"
.CLASS 83
.VALUE _globalLabelTable
.DIM 8192
.TAG "NONAME0"
.TYPE 360
.ENDEF
_globalLabelCounter:
	DS	2*1
.DEFINE "globalLabelCounter"
.ALIAS "_globalLabelCounter"
.CLASS 83
.VALUE _globalLabelCounter
.TYPE 13
.ENDEF
_localLabelTable:
	DS	448
.DEFINE "localLabelTable"
.ALIAS "_localLabelTable"
.CLASS 83
.VALUE _localLabelTable
.DIM 64
.TAG "NONAME0"
.TYPE 104
.ENDEF
_localLabelCounter:
	DS	2*1
.DEFINE "localLabelCounter"
.ALIAS "_localLabelCounter"
.CLASS 83
.VALUE _localLabelCounter
.TYPE 13
.ENDEF
;    1	#include <stdint.h>
;    2	#include <stdio.h>
;    3	#include <string.h>
;    4	#include "label.h"
;    5	#include "hash.h"
;    6	#include "str2num.h"
;    7	#include "utils.h"
;    8	#include "globals.h"
;    9	#include "stdint.h"
;   10	
;   11	// memory for anonymous labels
;   12	anonymouslabeltype an_prev;
;   13	anonymouslabeltype an_next;
;   14	label an_return;
;   15	
;   16	// memory buffer for sequentially storing label strings
;   17	char globalLabelBuffer[GLOBAL_LABEL_BUFFERSIZE];
;   18	char localLabelBuffer[LOCAL_LABEL_BUFFERSIZE];
;   19	uint16_t globalLabelBufferIndex;
;   20	uint16_t localLabelBufferIndex;
;   21	
;   22	// tables
;   23	label* globalLabelTable[GLOBAL_LABEL_TABLE_SIZE]; // hash table
;   24	uint16_t globalLabelCounter;
;   25	label localLabelTable[LOCAL_LABEL_TABLE_SIZE]; // indexed table
;   26	uint16_t localLabelCounter;
	SEGMENT CODE
;   27	
;   28	void printLocalLabelTable(void) {
_printLocalLabelTable:
.DEFINE "_printLocalLabelTable"

.VALUE _printLocalLabelTable

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "printLocalLabelTable",28,"_printLocalLabelTable"

.LINE 28

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
;   29	    int i;
;   30	    printf("\r\nLocal table (%d entries):\n\r",localLabelCounter);
.LINE 30

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,L__0
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(_localLabelCounter)
	CALL	__stoiu
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,L__1
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;   31	    for(i = 0; i < localLabelCounter; i++) printf("%08x - %s\n\r", localLabelTable[i].address, localLabelTable[i].name);
.LINE 31

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_3
L_1:
	LD	HL,(IX+%FFFFFFFD)
	LD	A,%7
	CALL	__imul_b
	LD	BC,_localLabelTable
	ADD	HL,BC
	LD	(IX+%FFFFFFFA),HL
	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	A,%8
	LD	(___print_fmt+5),A
	LD	A,%40
	LD	(___print_fmt+1),A
	LD	A,%78
	LD	(___print_fmt+4),A
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%3)
	LD	A,(IY+%6)
	LD	H,%0
	LD	L,A
	PUSH	HL
	PUSH	BC
	CALL	__u_uitoa
	POP	BC
	POP	BC
	LD	BC,L__2
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	IY,(IX+%FFFFFFFA)
	LD	BC,(IY+%0)
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,L__3
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
L_3:
	LD	BC,(_localLabelCounter)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_1
;   32	}
.LINE 32

	LD	SP,IX
	POP	IX
	RET	


;**************************** _printLocalLabelTable ***************************
;Name                         Addr/Register   Size   Type
;__u_uitoa                           IMPORT  -----   function
;___print_fmt                        IMPORT     19   variable
;_localLabelTable                    STATIC    448   variable
;_localLabelCounter                  STATIC      2   variable
;__u_itoa                            IMPORT  -----   function
;___print_sendstring                 IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function
;i                                     IX-3      3   variable


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "printLocalLabelTable",32,"_printLocalLabelTable"
	SEGMENT STRSECT
L__0:
	DB	13,10
	DB	"Local table ("
	DB	0
L__1:
	DB	" entries):"
	DB	10,13,0
L__2:
	DB	" - "
	DB	0
L__3:
	DB	10,13,0
	SEGMENT CODE
;   33	uint16_t getGlobalLabelCount(void) {
_getGlobalLabelCount:
.DEFINE "_getGlobalLabelCount"

.VALUE _getGlobalLabelCount

.CLASS 2

.TYPE 77

.ENDEF

.BEGFUNC "getGlobalLabelCount",33,"_getGlobalLabelCount"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   34	    return globalLabelCounter;
.LINE 34

	LD	HL,(_globalLabelCounter)
;   35	}
.LINE 35

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getGlobalLabelCount ***************************
;Name                         Addr/Register   Size   Type
;_globalLabelCounter                 STATIC      2   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getGlobalLabelCount",35,"_getGlobalLabelCount"
;   36	uint16_t getLocalLabelCount(void) {
_getLocalLabelCount:
.DEFINE "_getLocalLabelCount"

.VALUE _getLocalLabelCount

.CLASS 2

.TYPE 77

.ENDEF

.BEGFUNC "getLocalLabelCount",36,"_getLocalLabelCount"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   37	    return localLabelCounter;
.LINE 37

	LD	HL,(_localLabelCounter)
;   38	}
.LINE 38

	LD	SP,IX
	POP	IX
	RET	


;**************************** _getLocalLabelCount ***************************
;Name                         Addr/Register   Size   Type
;_localLabelCounter                  STATIC      2   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "getLocalLabelCount",38,"_getLocalLabelCount"
;   39	void initGlobalLabelTable(void) {
_initGlobalLabelTable:
.DEFINE "_initGlobalLabelTable"

.VALUE _initGlobalLabelTable

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "initGlobalLabelTable",39,"_initGlobalLabelTable"

.LINE 39

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;   40	    int i;
;   41	
;   42	    globalLabelBufferIndex = 0;
.LINE 42

	LD	HL,_globalLabelBufferIndex
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
;   43	    globalLabelCounter = 0;
.LINE 43

	LD	HL,_globalLabelCounter
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
;   44	    for(i = 0; i < GLOBAL_LABEL_TABLE_SIZE; i++){
.LINE 44

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_10
L_8:
;   45	        globalLabelTable[i] = NULL;
.LINE 45

	LD	HL,(IX+%FFFFFFFD)
	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_globalLabelTable
	ADD	HL,BC
	LD	BC,0
	LD	(HL),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;   46	    }
L_10:
.LINE 46

	LD	BC,8192
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_8
;   47	}
.LINE 47

	LD	SP,IX
	POP	IX
	RET	


;**************************** _initGlobalLabelTable ***************************
;Name                         Addr/Register   Size   Type
;_globalLabelTable                   STATIC  24576   variable
;_globalLabelCounter                 STATIC      2   variable
;_globalLabelBufferIndex             STATIC      2   variable
;i                                     IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "initGlobalLabelTable",47,"_initGlobalLabelTable"
;   48	
;   49	void initAnonymousLabelTable(void) {
_initAnonymousLabelTable:
.DEFINE "_initAnonymousLabelTable"

.VALUE _initAnonymousLabelTable

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "initAnonymousLabelTable",49,"_initAnonymousLabelTable"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   50	    an_prev.defined = false;
.LINE 50

	XOR	A,A
	LD	(_an_prev),A
;   51	    an_next.defined = false;
.LINE 51

	XOR	A,A
	LD	(_an_next),A
;   52	    an_return.name = NULL;
.LINE 52

	LD	BC,0
	LD	(_an_return),BC
;   53	}
.LINE 53

	LD	SP,IX
	POP	IX
	RET	


;**************************** _initAnonymousLabelTable ***************************
;Name                         Addr/Register   Size   Type
;_an_return                          STATIC      7   variable
;_an_next                            STATIC      5   variable
;_an_prev                            STATIC      5   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "initAnonymousLabelTable",53,"_initAnonymousLabelTable"
;   54	
;   55	void initLocalLabelTable(void) {
_initLocalLabelTable:
.DEFINE "_initLocalLabelTable"

.VALUE _initLocalLabelTable

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "initLocalLabelTable",55,"_initLocalLabelTable"

.LINE 55

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;   56	    int i;
;   57	
;   58	    localLabelBufferIndex = 0;
.LINE 58

	LD	HL,_localLabelBufferIndex
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
;   59	    localLabelCounter = 0;
.LINE 59

	LD	HL,_localLabelCounter
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
;   60	    for(i = 0; i < LOCAL_LABEL_TABLE_SIZE; i++) {
.LINE 60

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_16
L_14:
;   61	        localLabelTable[i].name = NULL;
.LINE 61

	LD	HL,(IX+%FFFFFFFD)
	LD	A,%7
	CALL	__imul_b
	LD	BC,_localLabelTable
	ADD	HL,BC
	LD	BC,0
	LD	IY,HL
	LD	(IY+%0),BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;   62	    }
L_16:
.LINE 62

	LD	BC,64
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_14
;   63	}
.LINE 63

	LD	SP,IX
	POP	IX
	RET	


;**************************** _initLocalLabelTable ***************************
;Name                         Addr/Register   Size   Type
;_localLabelTable                    STATIC    448   variable
;_localLabelCounter                  STATIC      2   variable
;_localLabelBufferIndex              STATIC      2   variable
;i                                     IX-3      3   variable


; Stack Frame Size: 9 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "initLocalLabelTable",63,"_initLocalLabelTable"
;   64	
;   65	void clearLocalLabels(void) {
_clearLocalLabels:
.DEFINE "_clearLocalLabels"

.VALUE _clearLocalLabels

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "clearLocalLabels",65,"_clearLocalLabels"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;   66	    localLabelBufferIndex = 0;
.LINE 66

	LD	HL,_localLabelBufferIndex
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
;   67	    localLabelCounter = 0;
.LINE 67

	LD	HL,_localLabelCounter
	LD	(HL),%0
	INC	HL
	LD	(HL),%0
;   68	}
.LINE 68

	LD	SP,IX
	POP	IX
	RET	


;**************************** _clearLocalLabels ***************************
;Name                         Addr/Register   Size   Type
;_localLabelCounter                  STATIC      2   variable
;_localLabelBufferIndex              STATIC      2   variable


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "clearLocalLabels",68,"_clearLocalLabels"
;   69	
;   70	int findLocalLabelIndex(char *key) {
_findLocalLabelIndex:
.DEFINE "_findLocalLabelIndex"

.VALUE _findLocalLabelIndex

.CLASS 2

.TYPE 68

.ENDEF

.BEGFUNC "findLocalLabelIndex",70,"_findLocalLabelIndex"

.LINE 70

.DEFINE "key"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "lim"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "p"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "cmp"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

.DEFINE "base"

.CLASS 65

.VALUE -12

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
;   71	    int base = 0;
.LINE 71

	LD	BC,0
	LD	(IX+%FFFFFFF4),BC
;   72		int lim, cmp;
;   73	    int p;
;   74	
;   75		for (lim = localLabelCounter; lim != 0; lim >>= 1) {
.LINE 75

	LD	BC,(_localLabelCounter)
	CALL	__stoiu
	LD	(IX+%FFFFFFFD),HL
	JR	L_25
L_23:
;   76			p = base + (lim >> 1);
.LINE 76

	LD	HL,(IX+%FFFFFFFD)
	LD	A,%1
	CALL	__ishrs_b
	LD	BC,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	(IX+%FFFFFFFA),HL
;   77			cmp = strcmp(key,localLabelTable[p].name);
.LINE 77

	LD	A,%7
	CALL	__imul_b
	LD	BC,_localLabelTable
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_strcmp
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF7),HL
;   78			if (cmp == 0)
.LINE 78

	CALL	__icmpzero
	JR	NZ,L_22
;   79				return p;
.LINE 79

	LD	HL,(IX+%FFFFFFFA)
	JR	L_27
L_22:
;   80			if (cmp > 0) {
.LINE 80

	LD	BC,(IX+%FFFFFFF7)
	OR	A,A
	SBC	HL,HL
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_24
;   81				base = p + 1;
.LINE 81

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFF4),BC
;   82				lim--;
.LINE 82

	LD	BC,(IX+%FFFFFFFD)
	DEC	BC
	LD	(IX+%FFFFFFFD),BC
;   83			}
;   84		}
L_24:
.LINE 84

	LD	HL,(IX+%FFFFFFFD)
	LD	A,%1
	CALL	__ishrs_b
	LD	(IX+%FFFFFFFD),HL
L_25:
	LD	HL,(IX+%FFFFFFFD)
	CALL	__icmpzero
	JR	NZ,L_23
;   85		return (LOCAL_LABEL_TABLE_SIZE);
.LINE 85

	LD	HL,64
;   86	}
L_27:
.LINE 86

	LD	SP,IX
	POP	IX
	RET	


;**************************** _findLocalLabelIndex ***************************
;Name                         Addr/Register   Size   Type
;_localLabelTable                    STATIC    448   variable
;_strcmp                             IMPORT  -----   function
;_localLabelCounter                  STATIC      2   variable
;base                                 IX-12      3   variable
;cmp                                   IX-9      3   variable
;p                                     IX-6      3   variable
;lim                                   IX-3      3   variable
;key                                   IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "findLocalLabelIndex",86,"_findLocalLabelIndex"
;   87	
;   88	label * findLocalLabel(char *key){
_findLocalLabel:
.DEFINE "_findLocalLabel"

.VALUE _findLocalLabel

.CLASS 2

.TAG "NONAME0"

.TYPE 328

.ENDEF

.BEGFUNC "findLocalLabel",88,"_findLocalLabel"

.LINE 88

.DEFINE "key"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "p"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
;   89	    int p = findLocalLabelIndex(key);
.LINE 89

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_findLocalLabelIndex
	POP	BC
	LD	(IX+%FFFFFFFD),HL
;   90	    if(p < LOCAL_LABEL_TABLE_SIZE) return &localLabelTable[p];
.LINE 90

	LD	BC,64
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_29
	LD	HL,(IX+%FFFFFFFD)
	LD	A,%7
	CALL	__imul_b
	LD	BC,_localLabelTable
	ADD	HL,BC
	JR	L_30
;   91	    else return NULL;
L_29:
.LINE 91

	OR	A,A
	SBC	HL,HL
;   92	}
L_30:
.LINE 92

	LD	SP,IX
	POP	IX
	RET	


;**************************** _findLocalLabel ***************************
;Name                         Addr/Register   Size   Type
;_localLabelTable                    STATIC    448   variable
;p                                     IX-3      3   variable
;key                                   IX+6      3   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "findLocalLabel",92,"_findLocalLabel"
;   93	
;   94	/*
;   95	size_t agon_specialfwrite(void *ptr, size_t size, size_t nmemb, uint8_t fileid) {
;   96	    size_t n, s, result = 0;
;   97	    char *target = (char *)ptr;
;   98	
;   99	    printf("\r\n");
;  100	    for(n = 0; n < nmemb; n++) {
;  101	        for(s = 0; s < size; s++) {
;  102	            //mos_fputc(filehandle[fileid], (*(char *)ptr));
;  103	            printf("%02x:",*target);
;  104	            target++;
;  105	            result++;
;  106	        }
;  107	    }
;  108	    printf("\r\n");
;  109	
;  110	    return result;
;  111	}*/
;  112	void writeLocalLabels(void) {
_writeLocalLabels:
.DEFINE "_writeLocalLabels"

.VALUE _writeLocalLabels

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "writeLocalLabels",112,"_writeLocalLabels"

.LINE 112

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "delta"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
	DEC	SP
;  113	    int i;
;  114	    uint16_t delta;
;  115	    // number of bytes in the string buffer
;  116	    agon_fwrite(&localLabelBufferIndex, sizeof(localLabelBufferIndex), 1, FILE_LOCAL_LABELS);
.LINE 116

	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,_localLabelBufferIndex
	PUSH	BC
	CALL	_agon_fwrite
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  117	    // the actual bytes from the string buffer
;  118	    if(localLabelBufferIndex) agon_fwrite(localLabelBuffer, localLabelBufferIndex, 1, FILE_LOCAL_LABELS);
.LINE 118

	LD	HL,(_localLabelBufferIndex)
	CALL	__scmpzero
	JR	Z,L_32
	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,(_localLabelBufferIndex)
	CALL	__stoiu
	PUSH	HL
	LD	BC,_localLabelBuffer
	PUSH	BC
	CALL	_agon_fwrite
	POP	BC
	POP	BC
	POP	BC
	POP	BC
L_32:
;  119	    // the number of labels
;  120	    agon_fwrite(&localLabelCounter, sizeof(localLabelCounter), 1, FILE_LOCAL_LABELS);
.LINE 120

	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,_localLabelCounter
	PUSH	BC
	CALL	_agon_fwrite
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  121	    for(i = 0; i < localLabelCounter; i++) {
.LINE 121

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_36
L_34:
;  122	        delta = localLabelTable[i].name - localLabelBuffer;
.LINE 122

	LD	HL,(IX+%FFFFFFFD)
	LD	A,%7
	CALL	__imul_b
	LD	BC,_localLabelTable
	ADD	HL,BC
	LD	IY,HL
	LD	HL,(IY+%0)
	LD	BC,_localLabelBuffer
	OR	A,A
	SBC	HL,BC
	LD	(IX+%FFFFFFFB),L
	LD	(IX+%FFFFFFFC),H
;  123	        agon_fwrite(&delta, sizeof(delta), 1, FILE_LOCAL_LABELS);
.LINE 123

	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFFB
	CALL	_agon_fwrite
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  124	        agon_fwrite(&localLabelTable[i].address, 4, 1, FILE_LOCAL_LABELS);
.LINE 124

	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	HL,(IX+%FFFFFFFD)
	LD	A,%7
	CALL	__imul_b
	LD	BC,_localLabelTable
	ADD	HL,BC
	LD	IY,HL
	PEA	IY+%3
	CALL	_agon_fwrite
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  125	        //printf("W: index %d, counter %d, delta %d, address %08x\r\n",localLabelBufferIndex, localLabelCounter, delta, localLabelTable[i].address);
;  126	    }
L_36:
.LINE 126

	LD	BC,(_localLabelCounter)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_34
;  127	}
.LINE 127

	LD	SP,IX
	POP	IX
	RET	


;**************************** _writeLocalLabels ***************************
;Name                         Addr/Register   Size   Type
;_localLabelTable                    STATIC    448   variable
;_localLabelCounter                  STATIC      2   variable
;_localLabelBuffer                   STATIC   4096   variable
;_localLabelBufferIndex              STATIC      2   variable
;_agon_fwrite                        IMPORT  -----   function
;delta                                 IX-5      2   variable
;i                                     IX-3      3   variable


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "writeLocalLabels",127,"_writeLocalLabels"
;  128	
;  129	void readLocalLabels(void) {
_readLocalLabels:
.DEFINE "_readLocalLabels"

.VALUE _readLocalLabels

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "readLocalLabels",129,"_readLocalLabels"

.LINE 129

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "delta"

.CLASS 65

.VALUE -5

.TYPE 13

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
	DEC	SP
;  130	    int i;
;  131	    uint16_t delta;
;  132	
;  133	    agon_fread(&localLabelBufferIndex, sizeof(localLabelBufferIndex), 1, FILE_LOCAL_LABELS);
.LINE 133

	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,_localLabelBufferIndex
	PUSH	BC
	CALL	_agon_fread
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  134	    if(localLabelBufferIndex) agon_fread(&localLabelBuffer, localLabelBufferIndex, 1, FILE_LOCAL_LABELS);
.LINE 134

	LD	HL,(_localLabelBufferIndex)
	CALL	__scmpzero
	JR	Z,L_39
	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,(_localLabelBufferIndex)
	CALL	__stoiu
	PUSH	HL
	LD	BC,_localLabelBuffer
	PUSH	BC
	CALL	_agon_fread
	POP	BC
	POP	BC
	POP	BC
	POP	BC
L_39:
;  135	    agon_fread(&localLabelCounter, sizeof(localLabelCounter), 1, FILE_LOCAL_LABELS);
.LINE 135

	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,2
	PUSH	BC
	LD	BC,_localLabelCounter
	PUSH	BC
	CALL	_agon_fread
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  136	    for(i = 0; i < localLabelCounter; i++) {
.LINE 136

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_43
L_41:
;  137	        agon_fread(&delta, sizeof(delta), 1, FILE_LOCAL_LABELS);
.LINE 137

	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,2
	PUSH	BC
	PEA	IX+%FFFFFFFB
	CALL	_agon_fread
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  138	        agon_fread(&localLabelTable[i].address, 4, 1, FILE_LOCAL_LABELS);
.LINE 138

	LD	BC,3
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,4
	PUSH	BC
	LD	HL,(IX+%FFFFFFFD)
	LD	A,%7
	CALL	__imul_b
	LD	BC,_localLabelTable
	ADD	HL,BC
	LD	IY,HL
	PEA	IY+%3
	CALL	_agon_fread
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  139	        localLabelTable[i].name = localLabelBuffer + delta;
.LINE 139

	LD	BC,(IX+%FFFFFFFB)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	LD	A,%7
	CALL	__imul_b
	LD	DE,_localLabelTable
	ADD	HL,DE
	LD	IY,HL
	LD	HL,_localLabelBuffer
	ADD	HL,BC
	LD	(IY+%0),HL
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  140	        //printf("R: index %d, counter %d, delta %d, address %08x\r\n",localLabelBufferIndex, localLabelCounter, delta, localLabelTable[i].address);
;  141	        //printf("R: index %d, counter %d, delta %d, address %08x\r\n",localLabelBufferIndex, localLabelCounter, delta, localLabelTable[i].address);
;  142	    }
L_43:
.LINE 142

	LD	BC,(_localLabelCounter)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_41
;  143	}
.LINE 143

	LD	SP,IX
	POP	IX
	RET	


;**************************** _readLocalLabels ***************************
;Name                         Addr/Register   Size   Type
;_localLabelTable                    STATIC    448   variable
;_localLabelCounter                  STATIC      2   variable
;_localLabelBuffer                   STATIC   4096   variable
;_localLabelBufferIndex              STATIC      2   variable
;_agon_fread                         IMPORT  -----   function
;delta                                 IX-5      2   variable
;i                                     IX-3      3   variable


; Stack Frame Size: 11 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "readLocalLabels",143,"_readLocalLabels"
;  144	
;  145	void writeAnonymousLabel(int32_t address) {
_writeAnonymousLabel:
.DEFINE "_writeAnonymousLabel"

.VALUE _writeAnonymousLabel

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "writeAnonymousLabel",145,"_writeAnonymousLabel"

.LINE 145

.DEFINE "address"

.CLASS 65

.VALUE 6

.TYPE 5

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  146	    agon_fwrite(&address, 1, sizeof(address), FILE_ANONYMOUS_LABELS);
.LINE 146

	LD	BC,4
	PUSH	BC
	PUSH	BC
	LD	BC,1
	PUSH	BC
	PEA	IX+%6
	CALL	_agon_fwrite
	POP	BC
	POP	BC
	POP	BC
	POP	BC
;  147	}
.LINE 147

	LD	SP,IX
	POP	IX
	RET	


;**************************** _writeAnonymousLabel ***************************
;Name                         Addr/Register   Size   Type
;_agon_fwrite                        IMPORT  -----   function
;address                               IX+6      4   parameter


; Stack Frame Size: 12 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "writeAnonymousLabel",147,"_writeAnonymousLabel"
;  148	
;  149	void readAnonymousLabel(void) {
_readAnonymousLabel:
.DEFINE "_readAnonymousLabel"

.VALUE _readAnonymousLabel

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "readAnonymousLabel",149,"_readAnonymousLabel"

.LINE 149

.DEFINE "address"

.CLASS 65

.VALUE -4

.TYPE 5

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	DEC	SP
;  150	    int32_t address;
;  151	
;  152	    if(agon_fread(&address, sizeof(address), 1, FILE_ANONYMOUS_LABELS)) {
.LINE 152

	LD	BC,4
	PUSH	BC
	LD	BC,1
	PUSH	BC
	LD	BC,4
	PUSH	BC
	PEA	IX+%FFFFFFFC
	CALL	_agon_fread
	POP	BC
	POP	BC
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	Z,L_49
;  153	        if(an_next.defined) {
.LINE 153

	LD	A,(_an_next)
	OR	A,A
	JR	Z,L_47
;  154	            an_prev.address = an_next.address;
.LINE 154

	LD	BC,(_an_next+1)
	LD	A,(_an_next+4)
	LD	(_an_prev+1),BC
	LD	(_an_prev+4),A
;  155	            an_prev.defined = true;
.LINE 155

	LD	A,%1
	LD	(_an_prev),A
;  156	        }
L_47:
.LINE 156

;  157	        an_next.address = address;
.LINE 157

	LD	BC,(IX+%FFFFFFFC)
	LD	(_an_next+1),BC
	LD	A,(IX+%FFFFFFFF)
	LD	(_an_next+4),A
;  158	        an_next.defined = true;            
.LINE 158

	LD	A,%1
	LD	(_an_next),A
;  159	    }
;  160	    else { // last label already read
.LINE 160

	JR	L_50
L_49:
;  161	        an_prev.address = an_next.address;
.LINE 161

	LD	BC,(_an_next+1)
	LD	A,(_an_next+4)
	LD	(_an_prev+1),BC
	LD	(_an_prev+4),A
;  162	        an_prev.defined = true;
.LINE 162

	LD	A,%1
	LD	(_an_prev),A
;  163	        an_next.defined = false;
.LINE 163

	XOR	A,A
	LD	(_an_next),A
;  164	    }
;  165	}
L_50:
.LINE 165

	LD	SP,IX
	POP	IX
	RET	


;**************************** _readAnonymousLabel ***************************
;Name                         Addr/Register   Size   Type
;_an_prev                            STATIC      5   variable
;_an_next                            STATIC      5   variable
;_agon_fread                         IMPORT  -----   function
;address                               IX-4      4   variable


; Stack Frame Size: 10 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "readAnonymousLabel",165,"_readAnonymousLabel"
;  166	
;  167	bool insertLocalLabel(char *labelname, int32_t address) {
_insertLocalLabel:
.DEFINE "_insertLocalLabel"

.VALUE _insertLocalLabel

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "insertLocalLabel",167,"_insertLocalLabel"

.LINE 167

.DEFINE "labelname"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "address"

.CLASS 65

.VALUE 9

.TYPE 5

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "ptr"

.CLASS 65

.VALUE -6

.TYPE 34

.ENDEF

.DEFINE "len"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

.DEFINE "old_name"

.CLASS 65

.VALUE -12

.TYPE 34

.ENDEF

.DEFINE "p"

.CLASS 65

.VALUE -15

.TYPE 4

.ENDEF

.DEFINE "old_address"

.CLASS 65

.VALUE -19

.TYPE 5

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEA
	LD	SP,HL
;  168	    int len,i;
;  169	    int p;
;  170	    char *ptr;
;  171	    char *old_name;
;  172	    int32_t old_address;
;  173	
;  174	    if(labelname[1] == 0) {
.LINE 174

	LD	HL,(IX+%6)
	INC	HL
	LD	A,(HL)
	OR	A,A
	JR	NZ,L_52
;  175	        error(message[ERROR_INVALIDLABEL]);
.LINE 175

	LD	HL,_message+12
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  176	        return false;
.LINE 176

	XOR	A,A
	JR	L_73
;  177	    }
L_52:
.LINE 177

;  178	    p = findLocalLabelIndex(labelname);
.LINE 178

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_findLocalLabelIndex
	POP	BC
	LD	(IX+%FFFFFFF1),HL
;  179	
;  180	    if(p >= LOCAL_LABEL_TABLE_SIZE) {
.LINE 180

	LD	BC,64
	LD	HL,(IX+%FFFFFFF1)
	OR	A,A
	SBC	HL,BC
	JP	M,L_71
;  181	        if(localLabelCounter < LOCAL_LABEL_TABLE_SIZE) {
.LINE 181

	LD.LIS	BC,64
	LD	HL,(_localLabelCounter)
	OR	A,A
	SBC.SIS	HL,BC
	JR	NC,L_69
;  182	            len = strlen(labelname);
.LINE 182

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+%FFFFFFF7),HL
;  183	            // check space first
;  184	            if((localLabelBufferIndex + len + 1) > LOCAL_LABEL_BUFFERSIZE -1)
.LINE 184

	LD	BC,(_localLabelBufferIndex)
	CALL	__stoiu
	LD	BC,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	BC,HL
	INC	BC
	LD	HL,4095
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	P,L_54
;  185	                return false; // no more space in buffer
.LINE 185

	XOR	A,A
	JR	L_73
L_54:
;  186	            // allocate space in buffer for string
;  187	            ptr = &localLabelBuffer[localLabelBufferIndex];
.LINE 187

	LD	BC,(_localLabelBufferIndex)
	CALL	__stoiu
	LD	BC,_localLabelBuffer
	ADD	HL,BC
	LD	(IX+%FFFFFFFA),HL
;  188	            localLabelBufferIndex += len + 1;
.LINE 188

	LD	BC,(IX+%FFFFFFF7)
	LD	HL,(_localLabelBufferIndex)
	ADD.SIS	HL,BC
	INC	HL
	LD	BC,HL
	LD	HL,_localLabelBufferIndex
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  189	            strcpy(ptr, labelname);
.LINE 189

	LD	BC,(IX+%6)
	PUSH	BC
	LD	BC,(IX+%FFFFFFFA)
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  190	
;  191	            for(i = 0; i < localLabelCounter; i++) {
.LINE 191

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_59
L_57:
;  192	                if(strcmp(labelname, localLabelTable[i].name) < 0) break;
.LINE 192

	LD	HL,(IX+%FFFFFFFD)
	LD	A,%7
	CALL	__imul_b
	LD	BC,_localLabelTable
	ADD	HL,BC
	LD	IY,HL
	LD	BC,(IY+%0)
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_strcmp
	POP	BC
	POP	BC
	CALL	__icmpzero
	CALL	__setflag
	JP	M,L_65
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  193	            }
L_59:
.LINE 193

	LD	BC,(_localLabelCounter)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_57
L_65:
;  194	            if(i < localLabelCounter) {
.LINE 194

	LD	BC,(_localLabelCounter)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_63
	JR	L_66
;  195	                for(; i < localLabelCounter; i++ ) {
L_61:
.LINE 195

;  196	                    old_name = localLabelTable[i].name;
.LINE 196

	LD	HL,(IX+%FFFFFFFD)
	LD	A,%7
	CALL	__imul_b
	LD	BC,_localLabelTable
	ADD	HL,BC
	LD	(IX+%FFFFFFEA),HL
	LD	IY,(IX+%FFFFFFEA)
	LD	BC,(IY+%0)
	LD	(IX+%FFFFFFF4),BC
;  197	                    old_address = localLabelTable[i].address;
.LINE 197

	LD	BC,(IY+%3)
	LD	A,(IY+%6)
	LD	(IX+%FFFFFFED),BC
	LD	(IX+%FFFFFFF0),A
;  198	                    localLabelTable[i].name = ptr;
.LINE 198

	LD	BC,(IX+%FFFFFFFA)
	LD	(IY+%0),BC
;  199	                    localLabelTable[i].address = address;
.LINE 199

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	(IY+%3),BC
	LD	(IY+%6),A
;  200	                    ptr = old_name;
.LINE 200

	LD	BC,(IX+%FFFFFFF4)
	LD	(IX+%FFFFFFFA),BC
;  201	                    address = old_address;
.LINE 201

	LD	BC,(IX+%FFFFFFED)
	LD	A,(IX+%FFFFFFF0)
	LD	(IX+%9),BC
	LD	(IX+%C),A
	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
;  202	                }
L_63:
.LINE 202

	LD	BC,(_localLabelCounter)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_61
;  203	            }
L_66:
.LINE 203

;  204	            localLabelTable[localLabelCounter].name = ptr;
.LINE 204

	LD	BC,(_localLabelCounter)
	CALL	__stoiu
	LD	A,%7
	CALL	__imul_b
	LD	BC,_localLabelTable
	ADD	HL,BC
	LD	BC,(IX+%FFFFFFFA)
	LD	IY,HL
	LD	(IY+%0),BC
;  205	            localLabelTable[localLabelCounter].address = address;
.LINE 205

	LD	BC,(_localLabelCounter)
	CALL	__stoiu
	LD	A,%7
	CALL	__imul_b
	LD	BC,_localLabelTable
	ADD	HL,BC
	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	IY,HL
	LD	(IY+%3),BC
	LD	(IY+%6),A
;  206	            localLabelCounter++;
.LINE 206

	LD	BC,(_localLabelCounter)
	INC	BC
	LD	HL,_localLabelCounter
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  207	            return true;
.LINE 207

	LD	A,%1
	JR	L_73
;  208	        }
;  209	        else error(message[ERROR_MAXLOCALLABELS]);
L_69:
.LINE 209

	LD	HL,_message+99
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
;  210	    }
;  211	    else error(message[ERROR_LABELDEFINED]);
.LINE 211

	JR	L_72
L_71:
	LD	HL,_message+96
	LD	BC,(HL)
	PUSH	BC
	CALL	_error
	POP	BC
L_72:
;  212	    return false;
.LINE 212

	XOR	A,A
;  213	}
L_73:
.LINE 213

	LD	SP,IX
	POP	IX
	RET	


;**************************** _insertLocalLabel ***************************
;Name                         Addr/Register   Size   Type
;_localLabelTable                    STATIC    448   variable
;_strcmp                             IMPORT  -----   function
;_strcpy                             IMPORT  -----   function
;_localLabelBuffer                   STATIC   4096   variable
;_localLabelBufferIndex              STATIC      2   variable
;_strlen                             IMPORT  -----   function
;_localLabelCounter                  STATIC      2   variable
;_message                            IMPORT  unknown variable
;_error                              IMPORT  -----   function
;old_address                          IX-19      4   variable
;p                                    IX-15      3   variable
;old_name                             IX-12      3   variable
;len                                   IX-9      3   variable
;ptr                                   IX-6      3   variable
;i                                     IX-3      3   variable
;address                               IX+9      4   parameter
;labelname                             IX+6      3   parameter


; Stack Frame Size: 37 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "insertLocalLabel",213,"_insertLocalLabel"
;  214	
;  215	bool insertGlobalLabel(char *labelname, int32_t address){
_insertGlobalLabel:
.DEFINE "_insertGlobalLabel"

.VALUE _insertGlobalLabel

.CLASS 2

.TYPE 76

.ENDEF

.BEGFUNC "insertGlobalLabel",215,"_insertGlobalLabel"

.LINE 215

.DEFINE "labelname"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "address"

.CLASS 65

.VALUE 9

.TYPE 5

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -3

.TYPE 4

.ENDEF

.DEFINE "tmp"

.CLASS 65

.VALUE -6

.TAG "NONAME0"

.TYPE 40

.ENDEF

.DEFINE "len"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

.DEFINE "try"

.CLASS 65

.VALUE -15

.TYPE 4

.ENDEF

.DEFINE "index"

.CLASS 65

.VALUE -18

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFEE
	LD	SP,HL
;  216	    int index,i,try,len;
;  217	    label *tmp;
;  218	
;  219	    len = strlen(labelname);
.LINE 219

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_strlen
	POP	BC
	LD	(IX+%FFFFFFF7),HL
;  220	    // check space first
;  221	    if((globalLabelBufferIndex + len + 1 + sizeof(label)) > GLOBAL_LABEL_TABLE_SIZE-1)
.LINE 221

	LD	BC,(_globalLabelBufferIndex)
	CALL	__stoiu
	LD	BC,(IX+%FFFFFFF7)
	ADD	HL,BC
	LD	IY,HL
	LEA	BC,IY+%8
	LD	HL,8191
	OR	A,A
	SBC	HL,BC
	JR	NC,L_75
;  222	        return false; // no more space in buffer 
.LINE 222

	XOR	A,A
	JR	L_83
L_75:
;  223	    // allocate space in buffer for label struct
;  224	    tmp = (label *)&globalLabelBuffer[globalLabelBufferIndex];
.LINE 224

	LD	BC,(_globalLabelBufferIndex)
	CALL	__stoiu
	LD	BC,_globalLabelBuffer
	ADD	HL,BC
	LD	(IX+%FFFFFFFA),HL
;  225	    globalLabelBufferIndex += sizeof(label);
.LINE 225

	LD	IY,(_globalLabelBufferIndex)
	LEA	BC,IY+%7
	LD	HL,_globalLabelBufferIndex
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  226	    // allocate space in buffer for string and store it to buffer
;  227	    tmp->name = &globalLabelBuffer[globalLabelBufferIndex];
.LINE 227

	LD	BC,(_globalLabelBufferIndex)
	CALL	__stoiu
	LD	BC,_globalLabelBuffer
	ADD	HL,BC
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%0),HL
;  228	    globalLabelBufferIndex += len+1;
.LINE 228

	LD	BC,(IX+%FFFFFFF7)
	LD	HL,(_globalLabelBufferIndex)
	ADD.SIS	HL,BC
	INC	HL
	LD	BC,HL
	LD	HL,_globalLabelBufferIndex
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  229	    strcpy(tmp->name, labelname);
.LINE 229

	LD	BC,(IX+%6)
	PUSH	BC
	LD	BC,(IY+%0)
	PUSH	BC
	CALL	_strcpy
	POP	BC
	POP	BC
;  230	    tmp->address = address;
.LINE 230

	LD	BC,(IX+%9)
	LD	A,(IX+%C)
	LD	IY,(IX+%FFFFFFFA)
	LD	(IY+%3),BC
	LD	(IY+%6),A
;  231	
;  232	    index = hash(labelname, GLOBAL_LABEL_TABLE_SIZE);
.LINE 232

	LD	BC,8192
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_hash
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFEE),HL
;  233	    for(i = 0; i < GLOBAL_LABEL_TABLE_SIZE; i++) {
.LINE 233

	LD	BC,0
	LD	(IX+%FFFFFFFD),BC
	JR	L_81
L_79:
;  234	        try = (i + index) % GLOBAL_LABEL_TABLE_SIZE;
.LINE 234

	LD	BC,(IX+%FFFFFFEE)
	LD	HL,(IX+%FFFFFFFD)
	ADD	HL,BC
	LD	BC,8192
	CALL	__irems
	LD	(IX+%FFFFFFF1),HL
;  235	        if(globalLabelTable[try] == NULL){
.LINE 235

	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_globalLabelTable
	ADD	HL,BC
	LD	(IX+%FFFFFFF4),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	NZ,L_80
;  236	            globalLabelTable[try] = tmp;
.LINE 236

	LD	HL,(IX+%FFFFFFF4)
	LD	BC,(IX+%FFFFFFFA)
	LD	(HL),BC
;  237	            globalLabelCounter++;
.LINE 237

	LD	BC,(_globalLabelCounter)
	INC	BC
	LD	HL,_globalLabelCounter
	LD	(HL),C
	INC	HL
	LD	(HL),B
;  238	            return true;
.LINE 238

	LD	A,%1
	JR	L_83
;  239	        } 
;  240	    }
L_80:
.LINE 240

	LD	BC,(IX+%FFFFFFFD)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
L_81:
	LD	BC,8192
	LD	HL,(IX+%FFFFFFFD)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_79
;  241	    return false;
.LINE 241

	XOR	A,A
;  242	}
L_83:
.LINE 242

	LD	SP,IX
	POP	IX
	RET	


;**************************** _insertGlobalLabel ***************************
;Name                         Addr/Register   Size   Type
;_globalLabelCounter                 STATIC      2   variable
;_globalLabelTable                   STATIC  24576   variable
;_hash                               IMPORT  -----   function
;_strcpy                             IMPORT  -----   function
;_globalLabelBuffer                  STATIC  131072   variable
;_globalLabelBufferIndex             STATIC      2   variable
;_strlen                             IMPORT  -----   function
;index                                IX-18      3   variable
;try                                  IX-15      3   variable
;G_0                                  IX-12      3   variable
;len                                   IX-9      3   variable
;tmp                                   IX-6      3   variable
;i                                     IX-3      3   variable
;address                               IX+9      4   parameter
;labelname                             IX+6      3   parameter


; Stack Frame Size: 33 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "insertGlobalLabel",242,"_insertGlobalLabel"
;  243	
;  244	void print_bufferspace(){
_print_bufferspace:
.DEFINE "_print_bufferspace"

.VALUE _print_bufferspace

.CLASS 2

.TYPE 65

.ENDEF

.BEGFUNC "print_bufferspace",244,"_print_bufferspace"

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
;  245	    printf("%d bytes available in label buffer\n", GLOBAL_LABEL_BUFFERSIZE - globalLabelBufferIndex );
.LINE 245

	LD	BC,___print_uputch
	LD	(___print_xputch),BC
	LD	BC,(_globalLabelBufferIndex)
	CALL	__stoiu
	LD	BC,HL
	LD	HL,131072
	OR	A,A
	SBC	HL,BC
	LD	BC,HL
	CALL	__itol
	LD	DE,BC
	LD	C,A
	LD	B,%0
	PUSH	BC
	PUSH	DE
	CALL	__u_itoa
	POP	BC
	POP	BC
	LD	BC,L__43
	PUSH	BC
	CALL	___print_sendstring
	POP	BC
;  246	}
.LINE 246

	LD	SP,IX
	POP	IX
	RET	


;**************************** _print_bufferspace ***************************
;Name                         Addr/Register   Size   Type
;___print_sendstring                 IMPORT  -----   function
;_globalLabelBufferIndex             STATIC      2   variable
;__u_itoa                            IMPORT  -----   function
;___print_xputch                     IMPORT      3   variable
;___print_uputch                     IMPORT  -----   function


; Stack Frame Size: 6 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "print_bufferspace",246,"_print_bufferspace"
	SEGMENT STRSECT
L__43:
	DB	" bytes available in label buffer"
	DB	10,0
	SEGMENT CODE
;  247	
;  248	label * findGlobalLabel(char *name){
_findGlobalLabel:
.DEFINE "_findGlobalLabel"

.VALUE _findGlobalLabel

.CLASS 2

.TAG "NONAME0"

.TYPE 328

.ENDEF

.BEGFUNC "findGlobalLabel",248,"_findGlobalLabel"

.LINE 248

.DEFINE "name"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

.DEFINE "i"

.CLASS 65

.VALUE -6

.TYPE 4

.ENDEF

.DEFINE "try"

.CLASS 65

.VALUE -9

.TYPE 4

.ENDEF

.DEFINE "index"

.CLASS 65

.VALUE -12

.TYPE 4

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	LEA	HL,IX+%FFFFFFF4
	LD	SP,HL
;  249	    int index,i,try;
;  250	
;  251	    index = hash(name, GLOBAL_LABEL_TABLE_SIZE);
.LINE 251

	LD	BC,8192
	PUSH	BC
	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_hash
	POP	BC
	POP	BC
	LD	(IX+%FFFFFFF4),HL
;  252	    for(i = 0; i < GLOBAL_LABEL_TABLE_SIZE; i++){
.LINE 252

	LD	BC,0
	LD	(IX+%FFFFFFFA),BC
	JR	L_92
L_90:
;  253	        try = (index + i) % GLOBAL_LABEL_TABLE_SIZE;
.LINE 253

	LD	BC,(IX+%FFFFFFFA)
	LD	HL,(IX+%FFFFFFF4)
	ADD	HL,BC
	LD	BC,8192
	CALL	__irems
	LD	(IX+%FFFFFFF7),HL
;  254	        if(globalLabelTable[try] == NULL){
.LINE 254

	LD	BC,HL
	ADD	HL,HL
	ADD	HL,BC
	LD	BC,_globalLabelTable
	ADD	HL,BC
	LD	(IX+%FFFFFFFD),HL
	LD	HL,(HL)
	CALL	__icmpzero
	JR	NZ,L_89
;  255	            return NULL;
.LINE 255

	OR	A,A
	SBC	HL,HL
	JR	L_94
;  256	        }
L_89:
.LINE 256

;  257	        if(globalLabelTable[try] != NULL &&
.LINE 257

	LD	HL,(IX+%FFFFFFFD)
	LD	HL,(HL)
	CALL	__icmpzero
	JR	Z,L_91
;  258	            strcmp(globalLabelTable[try]->name,name) == 0){
.LINE 258

	LD	BC,(IX+%6)
	PUSH	BC
	LD	HL,(IX+%FFFFFFFD)
	LD	IY,(HL)
	LD	BC,(IY+%0)
	PUSH	BC
	CALL	_strcmp
	POP	BC
	POP	BC
	CALL	__icmpzero
	JR	NZ,L_91
;  259	            return globalLabelTable[try];
.LINE 259

	LD	HL,(IX+%FFFFFFFD)
	LD	HL,(HL)
	JR	L_94
;  260	        }
;  261	    }
L_91:
.LINE 261

	LD	BC,(IX+%FFFFFFFA)
	INC	BC
	LD	(IX+%FFFFFFFA),BC
L_92:
	LD	BC,8192
	LD	HL,(IX+%FFFFFFFA)
	OR	A,A
	SBC	HL,BC
	CALL	__setflag
	JP	M,L_90
;  262	    return NULL;
.LINE 262

	OR	A,A
	SBC	HL,HL
;  263	}
L_94:
.LINE 263

	LD	SP,IX
	POP	IX
	RET	


;**************************** _findGlobalLabel ***************************
;Name                         Addr/Register   Size   Type
;_strcmp                             IMPORT  -----   function
;_globalLabelTable                   STATIC  24576   variable
;_hash                               IMPORT  -----   function
;index                                IX-12      3   variable
;try                                   IX-9      3   variable
;i                                     IX-6      3   variable
;G_1                                   IX-3      3   variable
;name                                  IX+6      3   parameter


; Stack Frame Size: 21 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "findGlobalLabel",263,"_findGlobalLabel"
;  264	
;  265	label *findLabel(char *name) {
_findLabel:
.DEFINE "_findLabel"

.VALUE _findLabel

.CLASS 2

.TAG "NONAME0"

.TYPE 328

.ENDEF

.BEGFUNC "findLabel",265,"_findLabel"

.LINE 265

.DEFINE "name"

.CLASS 65

.VALUE 6

.TYPE 34

.ENDEF

	PUSH	IX
	LD	IX,0
	ADD	IX,SP
	PUSH	BC
	PUSH	BC
	PUSH	BC
;  266	    if(name[0] == '@') {
.LINE 266

	LD	HL,(IX+%6)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,64
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_108
;  267	        
;  268	        if(((name[1] == 'f') || (name[1] == 'n')) && name[2] == 0) {
.LINE 268

	LD	BC,(IX+%6)
	INC	BC
	LD	(IX+%FFFFFFFD),BC
	LD	(IX+%FFFFFFFA),BC
	LD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,102
	OR	A,A
	SBC	HL,BC
	JR	Z,L_96
	LD	BC,(IX+%FFFFFFFD)
	LD	(IX+%FFFFFFFA),BC
	LD	HL,(IX+%FFFFFFFD)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,110
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_105
L_96:
	LD	IY,(IX+%6)
	LD	A,(IY+%2)
	OR	A,A
	JR	NZ,L_105
;  269	            if(an_next.defined) {
.LINE 269

	LD	A,(_an_next)
	OR	A,A
	JR	Z,L_98
;  270	                an_return.address = an_next.address;
.LINE 270

	LD	BC,(_an_next+1)
	LD	A,(_an_next+4)
	LD	(_an_return+3),BC
	LD	(_an_return+6),A
;  271	                return &an_return;
.LINE 271

	LD	HL,_an_return
	JR	L_109
;  272	            }
;  273	            else return NULL;
L_98:
.LINE 273

	OR	A,A
	SBC	HL,HL
	JR	L_109
;  274	        }
L_105:
.LINE 274

;  275	        if(((name[1] == 'b') || (name[1] == 'p')) && name[2] == 0) {
.LINE 275

	LD	BC,(IX+%FFFFFFFA)
	LD	(IX+%FFFFFFF7),BC
	LD	HL,BC
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,98
	OR	A,A
	SBC	HL,BC
	JR	Z,L_101
	LD	HL,(IX+%FFFFFFF7)
	LD	A,(HL)
	LD	B,A
	SEXT	HL
	LD	L,B
	LD	BC,112
	OR	A,A
	SBC	HL,BC
	JR	NZ,L_106
L_101:
	LD	IY,(IX+%6)
	LD	A,(IY+%2)
	OR	A,A
	JR	NZ,L_106
;  276	            if(an_prev.defined) {
.LINE 276

	LD	A,(_an_prev)
	OR	A,A
	JR	Z,L_103
;  277	                an_return.address = an_prev.address;
.LINE 277

	LD	BC,(_an_prev+1)
	LD	A,(_an_prev+4)
	LD	(_an_return+3),BC
	LD	(_an_return+6),A
;  278	                return &an_return;
.LINE 278

	LD	HL,_an_return
	JR	L_109
;  279	            }
;  280	            else return NULL;
L_103:
.LINE 280

	OR	A,A
	SBC	HL,HL
	JR	L_109
;  281	        }
L_106:
.LINE 281

;  282	        
;  283	        return findLocalLabel(name);
.LINE 283

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_findLocalLabel
	POP	BC
	JR	L_109
;  284	    }
;  285	    else return findGlobalLabel(name);
L_108:
.LINE 285

	LD	BC,(IX+%6)
	PUSH	BC
	CALL	_findGlobalLabel
	POP	BC
L_109:
.LINE 286

	LD	SP,IX
	POP	IX
	RET	


;**************************** _findLabel ***************************
;Name                         Addr/Register   Size   Type
;_findGlobalLabel                    IMPORT  -----   function
;_an_prev                            STATIC      5   variable
;_an_return                          STATIC      7   variable
;_an_next                            STATIC      5   variable
;G_6                                   IX-9      3   variable
;G_5                                   IX-6      3   variable
;G_4                                   IX-3      3   variable
;name                                  IX+6      3   parameter


; Stack Frame Size: 18 (bytes)
;       Spill Code: 0 (instruction)


.ENDFUNC "findLabel",286,"_findLabel"
	XREF _message:ROM
	XREF _agon_fread:ROM
	XREF _agon_fwrite:ROM
	XREF _error:ROM
	XREF _hash:ROM
	XREF _strlen:ROM
	XREF _strcmp:ROM
	XREF _strcpy:ROM
	XREF __u_uitoa:ROM
	XREF __u_itoa:ROM
	XREF ___print_sendstring:ROM
	XREF ___print_xputch:ROM
	XREF ___print_uputch:ROM
	XREF ___print_fmt:ROM
	XREF __irems:ROM
	XREF __stoiu:ROM
	XREF __itol:ROM
	XREF __setflag:ROM
	XREF __scmpzero:ROM
	XREF __icmpzero:ROM
	XREF __imul_b:ROM
	XREF __ishrs_b:ROM
	XDEF _findLabel
	XDEF _findGlobalLabel
	XDEF _print_bufferspace
	XDEF _insertGlobalLabel
	XDEF _insertLocalLabel
	XDEF _readAnonymousLabel
	XDEF _writeAnonymousLabel
	XDEF _readLocalLabels
	XDEF _writeLocalLabels
	XDEF _findLocalLabel
	XDEF _findLocalLabelIndex
	XDEF _clearLocalLabels
	XDEF _initLocalLabelTable
	XDEF _initAnonymousLabelTable
	XDEF _initGlobalLabelTable
	XDEF _getLocalLabelCount
	XDEF _getGlobalLabelCount
	XDEF _printLocalLabelTable
	XDEF _localLabelCounter
	XDEF _localLabelTable
	XDEF _globalLabelCounter
	XDEF _globalLabelTable
	XDEF _localLabelBufferIndex
	XDEF _globalLabelBufferIndex
	XDEF _localLabelBuffer
	XDEF _globalLabelBuffer
	XDEF _an_return
	XDEF _an_next
	XDEF _an_prev
	END
